---
phase: 05-token-gated-content
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - lib/solana/token-balance.ts
  - lib/content/access-control.ts
  - lib/media/image-processing.ts
  - lib/media/signed-urls.ts
  - lib/mux/client.ts
  - app/api/webhooks/mux/route.ts
  - app/api/media/confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "Token balance for a wallet+mint pair can be fetched from Helius RPC"
    - "Token balances are cached in the database with a 60-second TTL"
    - "Images processed for gated posts include a blurred placeholder variant"
    - "Videos in gated posts get a blurred thumbnail placeholder stored in R2"
    - "R2 presigned GET URLs can be generated for authorized image access"
    - "Mux signed playback tokens can be generated for authorized video access"
  artifacts:
    - path: "lib/solana/token-balance.ts"
      provides: "getTokenBalance() via Helius RPC getTokenAccountsByOwner"
      exports: ["getTokenBalance"]
    - path: "lib/content/access-control.ts"
      provides: "getCachedTokenBalance() with DB-backed TTL cache, checkContentAccess() for determining viewer access"
      exports: ["getCachedTokenBalance", "checkContentAccess"]
    - path: "lib/media/image-processing.ts"
      provides: "Extended processUploadedImage with blur variant generation"
      contains: "blur"
    - path: "lib/media/signed-urls.ts"
      provides: "generateSignedImageUrl() for R2 presigned GET, generateSignedPlaybackToken() for Mux video"
      exports: ["generateSignedImageUrl", "generateSignedPlaybackToken"]
  key_links:
    - from: "lib/content/access-control.ts"
      to: "lib/solana/token-balance.ts"
      via: "getCachedTokenBalance calls getTokenBalance on cache miss"
      pattern: "getTokenBalance"
    - from: "lib/content/access-control.ts"
      to: "lib/db/schema.ts"
      via: "reads/writes tokenBalanceCache table"
      pattern: "tokenBalanceCache"
    - from: "lib/media/image-processing.ts"
      to: "R2 storage"
      via: "uploadToR2 for blur variant"
      pattern: "blur\\.webp"
---

<objective>
Build the backend infrastructure for token-gated content: token balance verification, blur placeholder generation, and signed URL/token generation for authorized media access.

Purpose: This is the security backbone of content gating. It ensures: (1) token balances are checked efficiently with caching, (2) blurred placeholders are generated server-side so original media URLs never leak, and (3) authorized viewers receive time-limited signed URLs/tokens for content access.

Output: Four new library modules (token-balance, access-control, signed-urls) plus extensions to existing image-processing and Mux webhook handler.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-token-gated-content/05-CONTEXT.md
@.planning/phases/05-token-gated-content/05-RESEARCH.md
@.planning/phases/05-token-gated-content/05-01-SUMMARY.md
@lib/db/schema.ts
@lib/media/image-processing.ts
@lib/mux/client.ts
@lib/solana/balance.ts
@lib/storage/upload.ts
@app/api/webhooks/mux/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token balance fetching and cached access control modules</name>
  <files>lib/solana/token-balance.ts, lib/content/access-control.ts</files>
  <action>
**Create `lib/solana/token-balance.ts`:**
- Export `getTokenBalance(walletAddress: string, mintAddress: string): Promise<bigint>`
- Use raw fetch to HELIUS_RPC_URL (process.env.HELIUS_RPC_URL) with JSON-RPC method `getTokenAccountsByOwner`
- Parameters: `[walletAddress, { mint: mintAddress }, { encoding: "jsonParsed" }]`
- Parse response: iterate `result.value` array, sum `account.data.parsed.info.tokenAmount.amount` as BigInt
- Return BigInt(0) if no accounts found
- Throw if HELIUS_RPC_URL not configured

**Create `lib/content/access-control.ts`:**
- Import `db` from `@/lib/db`, schema tables, drizzle operators
- Import `getTokenBalance` from `@/lib/solana/token-balance`
- Define `BALANCE_CACHE_TTL_MS = 60_000` (60 seconds)

- Export `getCachedTokenBalance(walletAddress: string, mintAddress: string): Promise<bigint>`:
  1. Query tokenBalanceCache for matching walletAddress + mintAddress
  2. If found and age < TTL, return BigInt(cached.balance)
  3. Otherwise, call getTokenBalance() for fresh data
  4. Upsert into tokenBalanceCache (insert with onConflictDoUpdate on walletAddress+mintAddress composite — use the unique index from 05-01 schema)
  5. Return the fresh balance

- Export `checkContentAccess(postData: { accessLevel: string; tokenThreshold: string | null; creatorTokenId: string | null }, viewerWalletPublicKey: string | null): Promise<{ hasAccess: boolean; viewerBalance: string }>`:
  1. If accessLevel is "public", return { hasAccess: true, viewerBalance: "0" }
  2. If no viewerWalletPublicKey, return { hasAccess: false, viewerBalance: "0" }
  3. Look up creatorToken by creatorTokenId to get mintAddress
  4. Call getCachedTokenBalance(viewerWalletPublicKey, mintAddress)
  5. Compare balance >= BigInt(tokenThreshold ?? "0")
  6. Return { hasAccess, viewerBalance: balance.toString() }
  </action>
  <verify>
Run `npx tsc --noEmit` to verify compilation. Grep for `getTokenBalance` in token-balance.ts and `getCachedTokenBalance` in access-control.ts.
  </verify>
  <done>
Token balance fetching via Helius RPC works. Cached balance checking with 60s TTL implemented. Content access checking compares balance against threshold.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend image processing with blur variant, create signed URL helpers, update Mux for signed playback and video blur</name>
  <files>lib/media/image-processing.ts, lib/media/signed-urls.ts, lib/mux/client.ts, app/api/webhooks/mux/route.ts</files>
  <action>
**Extend `lib/media/image-processing.ts`:**
- Add a blur variant to `processUploadedImage`. After generating sm/md/lg variants, generate a blur variant:
  ```
  const blurKey = `${keyDir}blur.webp`;
  const blurBuffer = await sharp(imageBuffer)
    .resize(40, undefined, { fit: "inside", withoutEnlargement: true })
    .blur(20)
    .resize(400, undefined, { fit: "inside", withoutEnlargement: true, kernel: "cubic" })
    .webp({ quality: 60 })
    .toBuffer();
  await uploadToR2(blurKey, blurBuffer, "image/webp");
  variants["blur"] = `${cleanPublicUrl}/${blurKey}`;
  ```
- The blur variant is always generated (for all images, not just gated posts) — this is simpler since access level is set at publish time, after media is already processed. The blur URL is safe to be public (it's already heavily blurred).

**Create `lib/media/signed-urls.ts`:**
- Export `generateSignedImageUrl(key: string, expiresInSeconds = 300): Promise<string>`:
  - Use GetObjectCommand from @aws-sdk/client-s3 + getSignedUrl from @aws-sdk/s3-request-presigner
  - Use getR2Client() from @/lib/storage/upload
  - key is the R2 object key (not the public URL)
  - Return the presigned URL string

- Export `generateSignedPlaybackToken(playbackId: string, expirationMinutes = 15): { playbackToken: string; thumbnailToken: string }`:
  - Use getMuxClient() from @/lib/mux/client
  - Call `mux.jwt.signPlaybackId(playbackId, { type: "video", expiration: "${expirationMinutes}m" })` for playbackToken
  - Call `mux.jwt.signPlaybackId(playbackId, { type: "thumbnail", expiration: "${expirationMinutes}m" })` for thumbnailToken
  - Return both tokens

- Export helper `getR2KeyFromPublicUrl(publicUrl: string): string`:
  - Strip R2_PUBLIC_URL prefix from a public URL to get the R2 key
  - e.g. "https://cdn.example.com/content/xyz/abc/lg.webp" -> "content/xyz/abc/lg.webp"

**Update `lib/mux/client.ts`:**
- Add JWT signing key configuration to the Mux client initialization.
- When MUX_SIGNING_KEY_ID and MUX_PRIVATE_KEY env vars are present, pass them to the Mux constructor:
  ```
  const signingKeyId = process.env.MUX_SIGNING_KEY_ID;
  const privateKeyBase64 = process.env.MUX_PRIVATE_KEY;
  // Only add JWT config if signing keys are available
  const jwtConfig = signingKeyId && privateKeyBase64 ? {
    jwtSigningKey: signingKeyId,
    jwtPrivateKey: Buffer.from(privateKeyBase64, 'base64').toString('ascii'),
  } : {};
  ```
- Merge jwtConfig into the Mux constructor options

**Update `app/api/webhooks/mux/route.ts`:**
- In the `video.asset.ready` handler, after storing the playback ID and marking media as ready, add video blur placeholder generation:
  1. Fetch the Mux thumbnail: `https://image.mux.com/${playbackId}/thumbnail.jpg?width=400`
  2. Apply Sharp blur pipeline (same as images): resize to 40px -> blur(20) -> resize to 400px -> webp quality 60
  3. Upload blurred thumbnail to R2 at key `content/{creatorProfileId}/{mediaId}/blur.webp`
  4. Add "blur" entry to the media record's variants JSON (update the variants column)
- Get the creatorProfileId from the media record (it's already on the media table).
- This ensures all video media have blur variants available for gating, similar to images.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all files compile. Check that:
- image-processing.ts generates a blur variant
- signed-urls.ts exports generateSignedImageUrl and generateSignedPlaybackToken
- mux client.ts accepts JWT signing keys
- Mux webhook handler generates video blur placeholder
  </verify>
  <done>
All images have blur variants. Video blur placeholders generated on Mux asset.ready webhook. Signed image URLs and Mux playback tokens can be generated for authorized access. Mux client configured for JWT signing.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `lib/solana/token-balance.ts` exists with `getTokenBalance` export
3. `lib/content/access-control.ts` exists with `getCachedTokenBalance` and `checkContentAccess` exports
4. `lib/media/image-processing.ts` generates blur variant alongside sm/md/lg
5. `lib/media/signed-urls.ts` exists with `generateSignedImageUrl` and `generateSignedPlaybackToken` exports
6. `lib/mux/client.ts` accepts MUX_SIGNING_KEY_ID and MUX_PRIVATE_KEY env vars
7. Mux webhook generates video blur placeholder on asset.ready
</verification>

<success_criteria>
- Token balance verification works via Helius RPC with 60s TTL DB cache
- All content images include blur placeholders (generated server-side via Sharp)
- Video blur placeholders generated from Mux thumbnails on transcoding completion
- Presigned R2 GET URLs can be generated for authorized image access
- Mux signed playback/thumbnail tokens can be generated for authorized video access
</success_criteria>

<output>
After completion, create `.planning/phases/05-token-gated-content/05-02-SUMMARY.md`
</output>
