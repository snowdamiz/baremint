---
phase: 05-token-gated-content
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - app/api/posts/[id]/publish/route.ts
  - lib/content/post-queries.ts
  - components/content/post-composer.tsx
autonomous: true

user_setup:
  - service: mux
    why: "Signed video playback for gated content"
    env_vars:
      - name: MUX_SIGNING_KEY_ID
        source: "Mux Dashboard -> Settings -> Signing Keys -> Create key -> Key ID"
      - name: MUX_PRIVATE_KEY
        source: "Mux Dashboard -> Settings -> Signing Keys -> Create key -> Base64 encode the private key (.pem file)"

must_haves:
  truths:
    - "Creator can select access level (public, hold-gated, burn-gated) before publishing a post"
    - "Creator can set a token threshold for gated posts"
    - "Access level defaults to public"
    - "Access level and threshold are stored in the database on the post record"
    - "Publishing a gated post requires the creator to have a launched token"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "accessLevel, tokenThreshold, creatorTokenId columns on post table; tokenBalanceCache table"
      contains: "accessLevel.*text.*access_level"
    - path: "app/api/posts/[id]/publish/route.ts"
      provides: "Publish endpoint accepting accessLevel and tokenThreshold params"
      contains: "accessLevel"
    - path: "components/content/post-composer.tsx"
      provides: "Access level selection step before publishing"
      contains: "hold_gated"
  key_links:
    - from: "components/content/post-composer.tsx"
      to: "app/api/posts/[id]/publish/route.ts"
      via: "POST request with accessLevel and tokenThreshold in body"
      pattern: "accessLevel.*tokenThreshold"
    - from: "app/api/posts/[id]/publish/route.ts"
      to: "lib/db/schema.ts"
      via: "drizzle update setting accessLevel and tokenThreshold on post"
      pattern: "accessLevel.*tokenThreshold"
---

<objective>
Extend the database schema and publish flow to support token-gated content access levels.

Purpose: Creators need to set access levels (public, hold-gated, burn-gated) and token thresholds when publishing posts. This plan adds the data model foundation and the UI step for selecting access levels before publishing.

Output: Extended post table with access level columns, token balance cache table, updated publish API accepting access level params, and access level selection step in the post composer.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-token-gated-content/05-CONTEXT.md
@.planning/phases/05-token-gated-content/05-RESEARCH.md
@lib/db/schema.ts
@lib/content/post-queries.ts
@app/api/posts/[id]/publish/route.ts
@components/content/post-composer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend database schema with access level columns and token balance cache table</name>
  <files>lib/db/schema.ts</files>
  <action>
Add three new columns to the existing `post` table:
- `accessLevel`: text("access_level").notNull().default("public") — values: "public" | "hold_gated" | "burn_gated"
- `tokenThreshold`: text("token_threshold") — nullable, stores BigInt as string (matching existing `amountLamports` pattern in withdrawal table). Required when accessLevel is not "public".
- `creatorTokenId`: text("creator_token_id").references(() => creatorToken.id) — nullable FK to creatorToken table, links gated post to the specific token that gates it.

Add a new `tokenBalanceCache` table after the content tables section:
```
export const tokenBalanceCache = pgTable("token_balance_cache", {
  id: text("id").primaryKey(),
  walletAddress: text("wallet_address").notNull(),
  mintAddress: text("mint_address").notNull(),
  balance: text("balance").notNull(), // raw token amount as string (BigInt)
  checkedAt: timestamp("checked_at").notNull().defaultNow(),
});
```
Add a unique index on (walletAddress, mintAddress) for the cache table using drizzle's `uniqueIndex` helper on the table.

After editing, run `npx drizzle-kit push` to apply the migration. If push fails because of Neon connection, that's expected in local dev — the schema change is still valid.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify schema compiles. Grep for `accessLevel` and `tokenBalanceCache` in schema.ts to confirm both additions.
  </verify>
  <done>
Post table has accessLevel, tokenThreshold, and creatorTokenId columns. tokenBalanceCache table exists with walletAddress + mintAddress unique constraint. TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update publish API and post-queries to accept access level params, add access level step to post composer</name>
  <files>app/api/posts/[id]/publish/route.ts, lib/content/post-queries.ts, components/content/post-composer.tsx</files>
  <action>
**Update `lib/content/post-queries.ts`:**
- Modify the `publishPost` function signature to accept optional `accessLevel` (default "public"), `tokenThreshold` (string | null), and `creatorTokenId` (string | null) parameters.
- When publishing, if accessLevel is not "public", set the three new columns on the post record in the same update that sets status and publishedAt.
- Update `getPublishedPosts` and `getPostById` to include the new columns in their return data (they should come automatically from the select, but verify the types are correct).

**Update `app/api/posts/[id]/publish/route.ts`:**
- Parse request body using zod: `{ accessLevel: z.enum(["public", "hold_gated", "burn_gated"]).default("public"), tokenThreshold: z.string().optional() }`
- If accessLevel is not "public":
  - Require tokenThreshold (return 400 if missing)
  - Validate tokenThreshold is a valid BigInt string (try `BigInt(tokenThreshold)`, return 400 if NaN)
  - Look up the creator's token: `db.query.creatorToken.findFirst({ where: eq(creatorToken.creatorProfileId, profile.id) })` — return 403 "You must launch a token before creating gated content" if not found
  - Pass accessLevel, tokenThreshold, and token.id to `publishPost()`
- If accessLevel is "public", pass defaults (no threshold, no tokenId)
- Import `z` from "zod", `creatorToken` from schema, `eq` from drizzle-orm

**Update `components/content/post-composer.tsx`:**
- Add a two-step publish flow: when user clicks "Publish", instead of immediately publishing, show an "access level" step within the same dialog.
- Add state: `publishStep: "compose" | "access"` (default "compose"), `accessLevel: "public" | "hold_gated" | "burn_gated"` (default "public"), `tokenThreshold: string` (default "").
- When user clicks "Publish" button in compose step:
  - If there are unsaved changes, save the draft first
  - Set `publishStep` to "access"
- In the "access" step, show:
  - A heading "Set Access Level"
  - Three radio-style cards (or buttons):
    - "Public" (default, selected) — "Anyone can view this post"
    - "Hold-Gated" — "Viewers must hold tokens to unlock"
    - "Burn-Gated" — "Viewers must burn tokens to unlock (one-time purchase)"
  - If hold_gated or burn_gated is selected, show a number input for "Token threshold" with label "Minimum tokens required" and helper text "How many tokens must viewers hold/burn to access this post?"
  - A "Back" button to go back to compose step
  - A "Publish" button that calls the actual publish API with accessLevel and tokenThreshold
- Update the `handlePublish` function to send `{ accessLevel, tokenThreshold }` in the POST body to `/api/posts/${postId}/publish`
- Reset publishStep and access level state when dialog closes
- The tokenThreshold input should be a text input (not number) to handle large values. Validate it's a positive integer before allowing publish.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify all files compile. Check that the publish route imports zod and validates the body. Check that the post-composer has the access level step with radio options and threshold input.
  </verify>
  <done>
Publish API validates and stores accessLevel + tokenThreshold. Post composer shows access level selection step before publishing. Gated posts require a launched token. TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Schema file contains `accessLevel`, `tokenThreshold`, `creatorTokenId` columns on post table
3. Schema file contains `tokenBalanceCache` table with unique index
4. Publish route validates accessLevel enum and tokenThreshold BigInt
5. Publish route checks creator has a launched token for gated posts
6. Post composer has "compose" and "access" steps with proper UI for selecting access level and threshold
</verification>

<success_criteria>
- Database schema extended with access level support and token balance cache
- Publish API accepts and validates access level parameters
- Post composer includes access level selection step before publishing
- All TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-token-gated-content/05-01-SUMMARY.md`
</output>
