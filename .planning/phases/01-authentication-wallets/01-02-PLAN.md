---
phase: 01-authentication-wallets
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/solana/keypair.ts
  - lib/solana/balance.ts
  - lib/solana/price.ts
  - lib/auth.ts
  - app/(dashboard)/dashboard/page.tsx
  - app/(dashboard)/layout.tsx
  - components/wallet/wallet-widget.tsx
  - components/wallet/address-display.tsx
  - components/wallet/balance-display.tsx
autonomous: true

must_haves:
  truths:
    - "A Solana wallet is automatically created when a user signs up"
    - "Wallet private key is encrypted with AES-256-GCM before database storage"
    - "User sees their SOL balance (in USD primary, SOL secondary) on the dashboard"
    - "User sees a wallet widget in the dashboard sidebar"
    - "Wallet address is hidden by default with a show/hide toggle"
  artifacts:
    - path: "lib/solana/keypair.ts"
      provides: "Ed25519 keypair generation, AES-256-GCM encrypt/decrypt"
      exports: ["generateWalletKeypair", "encryptPrivateKey", "decryptPrivateKey"]
    - path: "lib/solana/balance.ts"
      provides: "SOL balance fetching via Helius RPC"
      exports: ["getSolBalance", "lamportsToSol"]
    - path: "lib/solana/price.ts"
      provides: "SOL/USD price via CoinGecko with caching"
      exports: ["getSolUsdPrice"]
    - path: "components/wallet/wallet-widget.tsx"
      provides: "Sidebar wallet widget with balance and address"
  key_links:
    - from: "lib/auth.ts"
      to: "lib/solana/keypair.ts"
      via: "Better Auth afterUserCreated hook or databaseHooks"
      pattern: "(afterUserCreated|databaseHooks|user.*create)"
    - from: "lib/solana/keypair.ts"
      to: "lib/db/schema.ts"
      via: "Insert into wallet table after encryption"
      pattern: "wallet"
    - from: "components/wallet/wallet-widget.tsx"
      to: "lib/solana/balance.ts"
      via: "Server component or server action fetching balance"
      pattern: "getSolBalance"
    - from: "components/wallet/balance-display.tsx"
      to: "lib/solana/price.ts"
      via: "USD conversion"
      pattern: "getSolUsdPrice"
---

<objective>
Create the custodial wallet system: automatic keypair generation on signup, AES-256-GCM encrypted storage, and a dashboard wallet widget showing balance.

Purpose: Users get a Solana wallet immediately on signup without any crypto knowledge. This is the foundation for all token and withdrawal features.
Output: Wallet auto-created on signup, encrypted in DB, balance displayed in dashboard sidebar widget.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-authentication-wallets/01-RESEARCH.md
@.planning/phases/01-authentication-wallets/01-CONTEXT.md
@.planning/phases/01-authentication-wallets/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Keypair generation, encryption, and wallet creation on signup</name>
  <files>
    lib/solana/keypair.ts
    lib/auth.ts
  </files>
  <action>
    1. Create `lib/solana/keypair.ts` with three functions:

       **generateWalletKeypair():**
       - Use Node.js `crypto.generateKeyPairSync('ed25519')` to generate an Ed25519 keypair (NOT @solana/kit's generateKeyPairSigner which produces non-extractable Web Crypto keys)
       - Extract raw public key bytes (32 bytes) and private key bytes (32 bytes) from the DER-encoded keys
       - For the public key: export as 'spki' DER format, extract last 32 bytes
       - For the private key: export as 'pkcs8' DER format, extract last 32 bytes
       - Convert public key bytes to base58 Solana address using @solana/kit's `address()` or a base58 encoder
       - Return { publicKey: string (base58), privateKeyBytes: Uint8Array (32 bytes) }

       **encryptPrivateKey(privateKeyBytes: Uint8Array, encryptionKey: Buffer): string**
       - Use exact pattern from research: AES-256-GCM, 12-byte random IV, returns "iv:authTag:encrypted" as base64 components
       - CRITICAL: Always use crypto.randomBytes(12) for IV -- never static or derived

       **decryptPrivateKey(encryptedString: string, encryptionKey: Buffer): Uint8Array**
       - Reverse of encrypt: parse "iv:authTag:encrypted", decrypt, return raw bytes

       **getEncryptionKey(): Buffer**
       - Read WALLET_ENCRYPTION_KEY from process.env
       - Must be 32 bytes (256 bits). Accept as hex string (64 chars) and convert to Buffer
       - Throw clear error if missing or wrong length

    2. Modify `lib/auth.ts` to add wallet creation on signup:
       - Use Better Auth's `databaseHooks` option to hook into user creation
       - In the `user.create.after` hook:
         a. Call generateWalletKeypair() to get publicKey + privateKeyBytes
         b. Call encryptPrivateKey() with the private key bytes
         c. Insert into the wallet table: { id: generated, userId: user.id, publicKey, encryptedPrivateKey }
       - Use `db` from lib/db to insert directly
       - Import the wallet table from schema
       - Generate wallet ID using crypto.randomUUID()

    IMPORTANT: The encryption key env var (WALLET_ENCRYPTION_KEY) must be set. Add to .env.example if not already there. For development, generate one: `node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"`
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - Create a new user account via the auth form -- verify in database that:
      - A row exists in the `wallet` table for the new user
      - `public_key` is a valid base58 Solana address (32-44 chars, starts with expected characters)
      - `encrypted_private_key` contains three colon-separated base64 strings
    - Encryption roundtrip: encrypting then decrypting returns original bytes
  </verify>
  <done>
    Every new user signup automatically creates a Solana wallet. Private key is AES-256-GCM encrypted with random IV before database storage. Encryption key is loaded from environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wallet widget with balance display on dashboard</name>
  <files>
    lib/solana/balance.ts
    lib/solana/price.ts
    components/wallet/wallet-widget.tsx
    components/wallet/address-display.tsx
    components/wallet/balance-display.tsx
    app/(dashboard)/dashboard/page.tsx
    app/(dashboard)/layout.tsx
  </files>
  <action>
    1. Create `lib/solana/balance.ts`:
       - getSolBalance(publicKey: string): Promise<bigint> -- fetch balance via Helius RPC using @solana/kit's createSolanaRpc
       - lamportsToSol(lamports: bigint): number -- convert lamports to SOL
       - Use HELIUS_RPC_URL from env. If not set, fall back to Solana devnet public RPC for development.

    2. Create `lib/solana/price.ts`:
       - getSolUsdPrice(): Promise<number> -- fetch from CoinGecko with 60-second in-memory cache
       - Use exact pattern from research (module-level cachedPrice variable)

    3. Create server action or API route for wallet data:
       - Create `lib/solana/get-wallet-data.ts` (or a server action in the dashboard)
       - Fetches wallet from DB by userId, gets SOL balance, gets USD price
       - Returns { publicKey, solBalance, usdBalance }
       - Handle case where HELIUS_RPC_URL is not set (return 0 balance with a note)

    4. Create `components/wallet/address-display.tsx`:
       - "Your Wallet" label
       - Address hidden by default (show "****...****")
       - "Show address" / "Hide address" toggle button
       - When shown: display full address with copy-to-clipboard button
       - Client component (uses useState for toggle)

    5. Create `components/wallet/balance-display.tsx`:
       - USD as primary display: large text "$185.10" format
       - SOL as secondary: smaller text below "0.95 SOL"
       - Handle zero balance: show "$0.00" / "0 SOL" with a friendly empty state message (Claude's discretion per CONTEXT.md)

    6. Create `components/wallet/wallet-widget.tsx`:
       - Combines address-display and balance-display
       - Card-style container with subtle border
       - Shows balance prominently, address toggle below

    7. Update `app/(dashboard)/layout.tsx`:
       - Add a sidebar to the dashboard layout
       - Sidebar contains the wallet widget
       - Main content area for page content
       - Responsive: sidebar collapses on mobile (or moves to top)

    8. Update `app/(dashboard)/dashboard/page.tsx`:
       - Fetch wallet data server-side (session + wallet query + balance)
       - Pass wallet data to the wallet widget
       - Keep the welcome message but make it more polished
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npm run build` succeeds
    - Dashboard shows wallet widget in sidebar
    - Wallet address is hidden by default, toggles on click
    - Balance shows USD primary and SOL secondary
    - New user signup shows wallet immediately (0 balance)
    - Copy address button copies to clipboard
  </verify>
  <done>
    Dashboard has a sidebar wallet widget showing USD balance (primary) and SOL balance (secondary). Wallet address is hidden by default with show/hide toggle. Zero balance shows a friendly empty state. Balance fetched from Helius RPC with CoinGecko USD conversion.
  </done>
</task>

</tasks>

<verification>
1. Sign up as a new user -- wallet widget appears immediately in dashboard sidebar
2. Wallet shows "$0.00" and "0 SOL" (new wallet, no funds)
3. Zero balance empty state looks friendly (not broken/empty)
4. Click "Show address" -- full Solana address appears
5. Click copy button -- address copied to clipboard
6. Click "Hide address" -- address hidden again
7. Check database: wallet row exists with encrypted_private_key in "iv:tag:data" format
8. Check database: public_key is valid base58 Solana address
</verification>

<success_criteria>
- Wallet auto-created on every new signup (no manual steps)
- Private keys encrypted with AES-256-GCM, random IV per encryption
- Encryption key loaded from WALLET_ENCRYPTION_KEY env var (not in code or DB)
- Dashboard sidebar shows wallet widget with USD primary / SOL secondary balance
- Wallet address hidden by default with toggle
- Works for zero-balance wallets (empty state)
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-wallets/01-02-SUMMARY.md`
</output>
