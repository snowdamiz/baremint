---
phase: 04-content-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/mux/client.ts
  - app/api/upload/video/route.ts
  - app/api/webhooks/mux/route.ts
autonomous: true
user_setup:
  - service: mux
    why: "Video transcoding, HLS delivery, CDN"
    env_vars:
      - name: MUX_TOKEN_ID
        source: "Mux Dashboard -> Settings -> API Access Tokens"
      - name: MUX_TOKEN_SECRET
        source: "Mux Dashboard -> Settings -> API Access Tokens"
      - name: MUX_WEBHOOK_SECRET
        source: "Mux Dashboard -> Settings -> Webhooks -> Signing Secret"
    dashboard_config:
      - task: "Create webhook endpoint pointing to /api/webhooks/mux"
        location: "Mux Dashboard -> Settings -> Webhooks"

must_haves:
  truths:
    - "Creator can initiate a video upload and get a Mux direct upload URL"
    - "Video is uploaded directly to Mux from the browser (not proxied through server)"
    - "Mux webhook updates media record when video asset is ready"
    - "Video duration limited to 10 minutes (enforced by Mux)"
    - "Webhook signature is verified before processing"
    - "Webhook handler is idempotent (safe for retries)"
  artifacts:
    - path: "lib/mux/client.ts"
      provides: "Mux SDK singleton client"
      contains: "new Mux"
    - path: "app/api/upload/video/route.ts"
      provides: "POST endpoint creating Mux direct upload with media record"
      exports: ["POST"]
    - path: "app/api/webhooks/mux/route.ts"
      provides: "Mux webhook handler for asset.ready and asset.errored"
      exports: ["POST"]
  key_links:
    - from: "app/api/upload/video/route.ts"
      to: "lib/mux/client.ts"
      via: "creates direct upload via mux.video.uploads.create"
      pattern: "mux\\.video\\.uploads\\.create"
    - from: "app/api/webhooks/mux/route.ts"
      to: "lib/db/schema.ts"
      via: "updates media record with playbackId and status"
      pattern: "media.*muxPlaybackId|status.*ready"
    - from: "app/api/webhooks/mux/route.ts"
      to: "lib/media/csam-scan.ts"
      via: "scans original video before marking ready"
      pattern: "scanMediaForCSAM"
---

<objective>
Build the video upload and transcoding pipeline using Mux: direct upload URL generation, CSAM scanning of original video, Mux transcoding with webhook completion, and media record lifecycle management.

Purpose: Video is a core content type. Mux handles transcoding to HLS with adaptive bitrate, CDN delivery, and thumbnail generation. CSAM scanning happens on the original file before Mux receives it.
Output: Working video upload flow where creator uploads to R2 first (for CSAM scan), then to Mux for transcoding, with webhooks updating media status on completion.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-content-infrastructure/04-RESEARCH.md
@.planning/phases/04-content-infrastructure/04-01-SUMMARY.md
@lib/db/schema.ts
@lib/storage/upload.ts
@lib/media/csam-scan.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Mux client and video upload API</name>
  <files>
    lib/mux/client.ts
    app/api/upload/video/route.ts
  </files>
  <action>
Run `npm install @mux/mux-node @mux/mux-uploader-react @mux/mux-player-react`.

**lib/mux/client.ts:**
- Create a lazy singleton Mux client (same Proxy pattern used for DB connection in this project)
- Initialize with `process.env.MUX_TOKEN_ID`, `process.env.MUX_TOKEN_SECRET`, `process.env.MUX_WEBHOOK_SECRET`
- Export `getMuxClient(): Mux`

**app/api/upload/video/route.ts:**
The video upload uses a two-phase approach per RESEARCH.md:
1. Upload original to R2 first (for CSAM scanning)
2. After CSAM scan passes, create Mux direct upload

POST endpoint:
- Auth check: require authenticated user with creatorProfile
- Accept `{ postId?: string }` (optional - video may be attached to post later)
- Step 1: Create media record in DB with type "video", status "uploading"
- Step 2: Generate R2 presigned URL for the original video (using generateContentMediaUploadUrl with "video/mp4")
- Return `{ mediaId, r2UploadUrl, r2Key }`

The client flow will be:
1. Upload video to R2 via presigned URL
2. Call POST /api/media/[id]/confirm (from Plan 02) which scans for CSAM
3. If scan passes, the confirm endpoint creates the Mux upload

Update the confirm endpoint logic for videos (extend Plan 02's app/api/media/[id]/confirm/route.ts):
- For video media (media.type === "video"):
  1. Update status to "scanning"
  2. Build R2 public URL from originalKey
  3. Call `scanMediaForCSAM(publicUrl)`
  4. If flagged: same flagging logic as images (set status "flagged", create moderationAction, update post)
  5. If clean:
     - Update status to "processing"
     - Create Mux direct upload: `mux.video.uploads.create({ cors_origin, new_asset_settings: { passthrough: mediaId, playback_policy: ["public"], video_quality: "basic", max_resolution_tier: "1080p" }, timeout: 600 })`
     - Note: Set Mux `max_duration_seconds: 600` on the upload to enforce 10-min limit
     - Store muxUploadId on media record
     - Return `{ status: "processing", muxUploadUrl: upload.url }` (client uses this URL with MuxUploader)

CRITICAL: The R2 upload happens first for CSAM scanning. Only after the scan passes does the client get a Mux upload URL. The original video stays in R2 for legal compliance.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. Run `npx tsx -e "import { getMuxClient } from './lib/mux/client'; console.log('Mux client OK')"` to verify import.</verify>
  <done>Mux client singleton created. Video upload endpoint creates media record and R2 presigned URL. Confirm endpoint extended to handle videos: CSAM scan on R2 original, then create Mux direct upload URL if clean. 10-minute duration enforced via Mux config.</done>
</task>

<task type="auto">
  <name>Task 2: Create Mux webhook handler for video completion</name>
  <files>app/api/webhooks/mux/route.ts</files>
  <action>
Create the Mux webhook handler at app/api/webhooks/mux/route.ts:

POST handler:
1. Read raw body with `request.text()` (NOT .json() - needed for signature verification)
2. Get headers from request
3. Verify webhook signature using `mux.webhooks.unwrap(body, headers)` - return 401 on invalid signature
4. Handle event types:

**"video.asset.ready":**
- Extract `asset.passthrough` as mediaId
- Extract `asset.playback_ids[0].id` as playbackId
- Extract `asset.duration` as duration (in seconds)
- IDEMPOTENCY CHECK: Query media record. If muxPlaybackId is already set, return 200 (already processed)
- Update media record: set muxAssetId = asset.id, muxPlaybackId = playbackId, duration = Math.round(duration), status = "ready"
- Check parent post: if all media for the post has status "ready" and post status is "processing", transition post to "published" with publishedAt = now()
- Return 200

**"video.asset.errored":**
- Extract `asset.passthrough` as mediaId
- Update media status to "failed"
- Return 200

**"video.upload.cancelled":**
- Extract passthrough as mediaId
- Update media status to "failed"
- Return 200

For any other event type, return 200 (acknowledge but ignore).

IMPORTANT: Always return 200 on processing errors (after signature verification) to prevent Mux retry storms. Log the error but return success. Pattern from Phase 3 Sumsub webhook: `Return 200 on webhook processing errors to prevent retry storms`.

Export config to disable body parsing: `export const runtime = "nodejs"` and ensure raw body is available.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. Webhook handler can be tested locally with a mock Mux event payload (signature verification will need to be temporarily bypassed in dev).</verify>
  <done>Mux webhook handler verifies signatures, handles asset.ready (updates playbackId/duration/status, publishes post if all media ready), asset.errored (marks failed), and upload.cancelled. All handlers are idempotent. Returns 200 to prevent retries.</done>
</task>

</tasks>

<verification>
- `npm install @mux/mux-node @mux/mux-uploader-react @mux/mux-player-react` succeeds
- `npm run build` passes with no type errors
- POST /api/upload/video creates media record and returns R2 presigned URL
- POST /api/media/[id]/confirm for video scans CSAM then returns Mux upload URL
- POST /api/webhooks/mux handles asset.ready and updates media/post status
- Webhook signature verification rejects invalid signatures
- Webhook handler is idempotent (duplicate events don't corrupt state)
</verification>

<success_criteria>
- Video upload flow: R2 first (for CSAM scan) -> Mux upload (for transcoding) -> webhook completion
- CSAM scan runs on original video before Mux ever sees it
- 10-minute duration enforced via Mux upload config
- Webhook handles ready/errored/cancelled events idempotently
- Post auto-publishes when all media reaches "ready" status
</success_criteria>

<output>
After completion, create `.planning/phases/04-content-infrastructure/04-03-SUMMARY.md`
</output>
