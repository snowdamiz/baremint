---
phase: 04-content-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/storage/upload.ts
  - lib/media/image-processing.ts
  - lib/media/csam-scan.ts
  - app/api/upload/presign/route.ts
  - app/api/media/[id]/confirm/route.ts
autonomous: true
user_setup:
  - service: hive-csam
    why: "CSAM scanning for all uploaded media"
    env_vars:
      - name: HIVE_CSAM_API_KEY
        source: "Contact sales@thehive.ai for CSAM API access"

must_haves:
  truths:
    - "Creator can upload an image up to 25MB via presigned URL"
    - "Uploaded image is scanned for CSAM before processing"
    - "Image is optimized into 3 responsive WebP variants (400, 800, 1200px)"
    - "Original image is preserved in R2 under originals/ prefix"
    - "Flagged images are held and not made publicly visible"
    - "Media record status transitions through uploading -> scanning -> processing -> ready (or flagged)"
  artifacts:
    - path: "lib/storage/upload.ts"
      provides: "Extended presigned URL generation for content media (25MB limit)"
    - path: "lib/media/image-processing.ts"
      provides: "Sharp pipeline: download from R2, resize to 3 sizes, output WebP at quality 80"
    - path: "lib/media/csam-scan.ts"
      provides: "Hive CSAM API integration with hash match and classifier detection"
    - path: "app/api/upload/presign/route.ts"
      provides: "Extended presign endpoint that creates media record and returns presigned URL"
    - path: "app/api/media/[id]/confirm/route.ts"
      provides: "Upload confirmation endpoint that triggers scan -> process pipeline"
  key_links:
    - from: "app/api/media/[id]/confirm/route.ts"
      to: "lib/media/csam-scan.ts"
      via: "calls scanMediaForCSAM with R2 URL"
      pattern: "scanMediaForCSAM"
    - from: "app/api/media/[id]/confirm/route.ts"
      to: "lib/media/image-processing.ts"
      via: "calls processUploadedImage after scan passes"
      pattern: "processUploadedImage"
    - from: "lib/media/image-processing.ts"
      to: "lib/storage/upload.ts"
      via: "downloads original from R2, uploads variants back to R2"
      pattern: "uploadToR2|downloadFromR2"
---

<objective>
Build the image upload pipeline: presigned URL generation for content media, CSAM scanning via Hive API, and Sharp image optimization into responsive WebP variants.

Purpose: Images are the primary content type. This plan creates the full upload -> scan -> process -> ready pipeline that all image posts depend on.
Output: Working image upload flow where creator uploads to R2, server scans for CSAM, processes into 3 responsive sizes, and updates media record status.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-content-infrastructure/04-RESEARCH.md
@.planning/phases/04-content-infrastructure/04-01-SUMMARY.md
@lib/storage/upload.ts
@lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Sharp and create CSAM scan + image processing modules</name>
  <files>
    lib/media/csam-scan.ts
    lib/media/image-processing.ts
    lib/storage/upload.ts
  </files>
  <action>
Run `npm install sharp` (mux packages installed in Plan 03).

**lib/media/csam-scan.ts:**
Create the CSAM scanning module using Hive Combined CSAM Detection API:
- Export `scanMediaForCSAM(mediaUrl: string): Promise<CSAMScanResult>`
- CSAMScanResult type: `{ flagged: boolean; reason?: "hash_match" | "classifier"; confidence?: number; rawResponse?: unknown }`
- POST to `https://api.thehive.ai/api/v2/task/sync` with FormData containing the URL
- Authorization header: `Token ${process.env.HIVE_CSAM_API_KEY}`
- Check `output.reasons` for "matched" (hash match = known CSAM)
- Check `output.classifierPrediction.csam_classifier.csam > 0.5` (AI classifier)
- Throw error if HIVE_CSAM_API_KEY not configured
- Throw error on non-200 response (do NOT silently pass)
- Export the CSAMScanResult type

**lib/media/image-processing.ts:**
Create the Sharp image processing pipeline:
- Export `processUploadedImage(imageBuffer: Buffer, baseKey: string): Promise<Record<string, string>>`
- Generate 3 responsive sizes: { sm: 400px, md: 800px, lg: 1200px }
- Output format: WebP at quality 80
- Use `withoutEnlargement: true` to avoid upscaling small images
- Use `fit: "inside"` to maintain aspect ratio
- Variant keys: replace `/original.ext` in baseKey with `/{suffix}.webp`
- Upload each variant to R2 and return a map of `{ sm: publicUrl, md: publicUrl, lg: publicUrl }`
- Export `downloadFromR2(key: string): Promise<Buffer>` - download file from R2 using GetObjectCommand
- Export `uploadToR2(key: string, buffer: Buffer, contentType: string): Promise<void>` - upload to R2 using PutObjectCommand

**lib/storage/upload.ts:**
Extend the existing file:
- Add video content types to a new `CONTENT_MEDIA_TYPES` array: `["image/jpeg", "image/png", "image/webp", "video/mp4", "video/quicktime"]`
- Add `MAX_CONTENT_IMAGE_SIZE = 25 * 1024 * 1024` (25MB)
- Export `generateContentMediaUploadUrl(creatorProfileId: string, contentType: string, mediaId: string)` - generates presigned URL with key pattern `content/{creatorProfileId}/{mediaId}/original.{ext}`. Use the 25MB limit for images. Return `{ uploadUrl, key }`.
- Export `getR2Client()` (currently private - make it exported so image-processing.ts can use it)
- Export `getExtensionFromContentType()` (currently private - make it exported). Add video extensions: `"video/mp4": "mp4"`, `"video/quicktime": "mov"`.
- Keep existing `generatePresignedUploadUrl` and `MAX_CONTENT_LENGTH` unchanged for backward compatibility with avatar/banner uploads.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. Run `npx tsx -e "import { scanMediaForCSAM } from './lib/media/csam-scan'; import { processUploadedImage } from './lib/media/image-processing'; import { generateContentMediaUploadUrl } from './lib/storage/upload'; console.log('All exports OK')"` to verify imports.</verify>
  <done>Three modules created: csam-scan.ts exports scanMediaForCSAM, image-processing.ts exports processUploadedImage/downloadFromR2/uploadToR2, upload.ts extended with generateContentMediaUploadUrl and exported helpers.</done>
</task>

<task type="auto">
  <name>Task 2: Create presign and confirm API endpoints for image upload pipeline</name>
  <files>
    app/api/upload/presign/route.ts
    app/api/media/[id]/confirm/route.ts
  </files>
  <action>
**app/api/upload/presign/route.ts:**
Extend the existing presign route (or create if it only handles avatar/banner). Add handling for `purpose: "post-media"`:
- Accept POST: `{ contentType: string, purpose: "post-media" | "avatar" | "banner", postId?: string }`
- For purpose "post-media":
  1. Validate contentType is in CONTENT_MEDIA_TYPES
  2. Auth check: require authenticated user with a creatorProfile
  3. Create a media record in DB: generate UUID, set type based on contentType (image or video), status "uploading", set creatorProfileId, postId if provided
  4. Call `generateContentMediaUploadUrl(creatorProfileId, contentType, mediaId)`
  5. Store originalKey on the media record
  6. Return `{ uploadUrl, mediaId, key }`
- For purpose "avatar"/"banner": keep existing behavior (use existing generatePresignedUploadUrl)
- Validate image contentType is one of jpeg/png/webp. Video types handled in Plan 03.

**app/api/media/[id]/confirm/route.ts:**
Create new endpoint for upload confirmation:
- POST: Triggers the scan -> process pipeline for a completed upload
- Auth check: require authenticated user, verify media record belongs to their creatorProfile
- Verify media status is "uploading" (prevent reprocessing)
- For images (media.type === "image"):
  1. Update media status to "scanning"
  2. Build the R2 public URL from the originalKey
  3. Call `scanMediaForCSAM(publicUrl)`
  4. If flagged:
     - Update media status to "flagged"
     - Create moderationAction record with action "flag_csam", reason from scan result, confidence
     - Update parent post status to "under_review" if post exists
     - Return `{ status: "flagged" }`
  5. If clean:
     - Update media status to "processing"
     - Download original from R2 using downloadFromR2
     - Call processUploadedImage(buffer, originalKey)
     - Update media record: status "ready", variants (the responsive URLs), width/height from Sharp metadata
     - Check if parent post (if exists) has all media ready -> if so and post status is "processing", transition post to "published"
     - Return `{ status: "ready", variants }`
- For videos: return `{ status: "pending", message: "Video processing handled separately" }` (Plan 03 handles this)
- Wrap the scan+process in try/catch: if any step fails, set media status to "failed" and return 500

IMPORTANT: The scan and process happen synchronously in this request. For MVP this is acceptable since Sharp processing is fast (< 5 seconds for a 25MB image). If performance becomes an issue, this can be moved to a background job later.
  </action>
  <verify>Run `npm run build` to verify no TypeScript errors. The full flow can be tested with curl:
1. `curl -X POST /api/upload/presign -d '{"contentType":"image/jpeg","purpose":"post-media"}' --cookie session` returns uploadUrl and mediaId
2. Upload a test image to the presigned URL
3. `curl -X POST /api/media/{mediaId}/confirm --cookie session` returns status "ready" with variants (requires HIVE_CSAM_API_KEY and R2 configured)
  </verify>
  <done>Image upload pipeline works end-to-end: presign creates media record + returns upload URL, confirm triggers CSAM scan then Sharp processing, media transitions through uploading -> scanning -> processing -> ready (or flagged). Flagged media creates moderation record and puts post under review.</done>
</task>

</tasks>

<verification>
- `npm install sharp` succeeds
- `npm run build` passes with no type errors
- POST /api/upload/presign with purpose "post-media" creates media record and returns presigned URL
- POST /api/media/[id]/confirm triggers scan -> process pipeline
- Media status transitions: uploading -> scanning -> processing -> ready
- Flagged media creates moderationAction and puts post under_review
- Image variants are 3 WebP files at 400, 800, 1200px widths
</verification>

<success_criteria>
- CSAM scan module calls Hive API and correctly parses hash_match and classifier results
- Sharp produces 3 responsive WebP variants stored in R2
- Original image preserved in R2 (not deleted after processing)
- Media status transitions are atomic and correct
- Flagged content triggers moderation action and post status change
</success_criteria>

<output>
After completion, create `.planning/phases/04-content-infrastructure/04-02-SUMMARY.md`
</output>
