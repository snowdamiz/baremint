---
phase: 06-token-trading
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/api/webhooks/helius/route.ts
  - lib/helius/webhook.ts
autonomous: true
user_setup:
  - service: helius
    why: "Webhook management requires separate API key"
    env_vars:
      - name: HELIUS_API_KEY
        source: "Helius Dashboard -> API Keys (same key as in HELIUS_RPC_URL path, but extracted standalone)"

must_haves:
  truths:
    - "Helius webhook endpoint receives transaction notifications and updates trade status from pending to confirmed"
    - "Duplicate webhook deliveries do not create duplicate trade records (idempotent via txSignature unique key)"
    - "Webhook handler returns 200 even on processing errors to prevent retry storms"
    - "Helius webhook can be registered programmatically for a bonding curve PDA address"
  artifacts:
    - path: "app/api/webhooks/helius/route.ts"
      provides: "POST handler for Helius webhook notifications"
      exports: ["POST"]
    - path: "lib/helius/webhook.ts"
      provides: "registerTradeWebhook utility for programmatic webhook creation"
      exports: ["registerTradeWebhook"]
  key_links:
    - from: "app/api/webhooks/helius/route.ts"
      to: "lib/db/schema.ts"
      via: "Update trade.status from pending to confirmed using txSignature"
      pattern: "import.*trade.*from.*schema"
    - from: "lib/helius/webhook.ts"
      to: "helius-sdk"
      via: "Helius SDK createWebhook API"
      pattern: "import.*Helius.*from.*helius-sdk"
---

<objective>
Create the Helius webhook endpoint for trade confirmation and off-chain ledger sync, plus a utility to register webhooks programmatically.

Purpose: Without webhooks, trades stay in "pending" status forever. The webhook confirms transactions on-chain and updates the off-chain trade ledger, which is required for transaction history (Plan 05) and OHLCV chart data (Plan 04).

Output: POST endpoint at `/api/webhooks/helius` that processes trade confirmations, and a `registerTradeWebhook` utility.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-token-trading/06-RESEARCH.md
@.planning/phases/06-token-trading/06-01-SUMMARY.md

@lib/db/schema.ts — trade table with txSignature unique constraint
@app/api/webhooks/mux/route.ts — Existing webhook handler pattern (return 200 always, signature verification, idempotency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Helius webhook endpoint for trade confirmation</name>
  <files>app/api/webhooks/helius/route.ts</files>
  <action>
Create `app/api/webhooks/helius/route.ts` — POST handler:

**Request format:** Helius raw webhooks send an array of transaction objects in the POST body (JSON array).

**Handler logic:**
1. Parse request body as JSON array. If parsing fails, return 200 with error log (never return 4xx/5xx to prevent retry storms).
2. Optional: Verify webhook authenticity via `Authorization` header if `HELIUS_WEBHOOK_SECRET` is set. If secret mismatch, log warning but still return 200.
3. For each transaction in the array:
   a. Extract signature from `tx.transaction.signatures[0]` (raw webhook format) or `tx.signature` (enhanced format). Handle both formats defensively.
   b. If no signature found, skip this entry (log warning).
   c. Query the `trade` table for a record with this `txSignature` and status `pending`.
   d. If no matching trade found, skip (this may be a non-trade transaction on the PDA, or a trade we didn't initiate).
   e. If found, determine if the transaction was successful:
      - Check `tx.meta.err` — if null, transaction succeeded
      - If `tx.meta.err` is non-null, mark trade as `failed`
   f. Update trade record: set `status` to "confirmed" (or "failed"), set `confirmedAt` to `new Date()`.
   g. Use `db.update(trade).set({ status, confirmedAt }).where(and(eq(trade.txSignature, signature), eq(trade.status, "pending")))` — the WHERE clause on status=pending provides idempotency.
4. Return `new Response("OK", { status: 200 })` always.

**Error handling:** Wrap entire handler in try/catch. On any error, log it and return 200. Follow the same pattern as `app/api/webhooks/mux/route.ts` (return 200 to prevent retry storms).

Import `db` from `@/lib/db`, `trade` from `@/lib/db/schema`, `eq`, `and` from `drizzle-orm`.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- POST handler always returns 200 status
- Trade status update uses WHERE status=pending for idempotency
- Both success (meta.err === null) and failure (meta.err !== null) cases handled
  </verify>
  <done>
- Helius webhook endpoint at /api/webhooks/helius processes trade confirmations
- Pending trades updated to confirmed or failed based on on-chain result
- Idempotent: duplicate deliveries don't create issues (WHERE status=pending)
- Always returns 200 to prevent retry storms
  </done>
</task>

<task type="auto">
  <name>Task 2: Programmatic webhook registration utility</name>
  <files>lib/helius/webhook.ts</files>
  <action>
Create `lib/helius/webhook.ts`:

**Export `registerTradeWebhook(bondingCurveAddress: string)`:**
1. Import `Helius` from `helius-sdk`
2. Read `HELIUS_API_KEY` from process.env. If not set, log warning and return null (don't crash — webhook setup is not blocking for trade execution).
3. Read `NEXT_PUBLIC_APP_URL` from process.env for the webhook URL.
4. Call `helius.createWebhook()` with:
   - `accountAddresses: [bondingCurveAddress]`
   - `transactionTypes: ["ANY"]` (we filter in our handler)
   - `webhookURL: \`\${NEXT_PUBLIC_APP_URL}/api/webhooks/helius\``
   - `webhookType: "raw"` for lower latency
5. Return the webhook ID on success, null on error (with console.error log).

**Export `deleteTradeWebhook(webhookId: string)`:**
- For cleanup if needed. Call `helius.deleteWebhook(webhookId)`.

Note: This utility is for future use — it can be called during token creation (extending create-token flow) or via an admin action. Plan 06-01's trade flow works without webhooks (trades just stay "pending" until webhook confirms them). The webhook registration will be integrated in a follow-up or can be done manually via Helius dashboard for MVP.
  </action>
  <verify>
- `npx tsc --noEmit` passes
- registerTradeWebhook gracefully handles missing HELIUS_API_KEY (returns null, doesn't throw)
- Function uses correct Helius SDK v2 API (Helius class, createWebhook method)
  </verify>
  <done>
- lib/helius/webhook.ts exports registerTradeWebhook and deleteTradeWebhook
- Graceful degradation when HELIUS_API_KEY is not set
- Uses Helius SDK v2 createWebhook API with raw webhook type
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for all new files
- Webhook endpoint correctly handles raw Helius webhook format
- Trade confirmation updates are idempotent
- Webhook registration utility works with Helius SDK v2
</verification>

<success_criteria>
- POST /api/webhooks/helius confirms pending trades based on on-chain results
- Duplicate webhook deliveries handled gracefully
- Platform fee and creator fee are tracked per-trade in the trade table (from Plan 01)
- Programmatic webhook registration available for future integration
</success_criteria>

<output>
After completion, create `.planning/phases/06-token-trading/06-03-SUMMARY.md`
</output>
