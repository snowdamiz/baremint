---
phase: 06-token-trading
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/solana/bonding-curve-math.ts
  - lib/solana/bonding-curve-read.ts
  - lib/solana/trade.ts
  - lib/db/schema.ts
  - app/trade/[token]/actions.ts
autonomous: true

must_haves:
  truths:
    - "Server action can construct and submit a buy transaction to the bonding curve program"
    - "Server action can construct and submit a sell transaction to the bonding curve program"
    - "TypeScript bonding curve math matches on-chain constant-product math exactly"
    - "Trade records are persisted in the database with pending status after submission"
  artifacts:
    - path: "lib/solana/bonding-curve-math.ts"
      provides: "Constant-product math (calculateBuyTokens, calculateSellSol, calculateFee, estimateBuy, estimateSell)"
      exports: ["calculateBuyTokens", "calculateSellSol", "calculateFee", "estimateBuy", "estimateSell"]
    - path: "lib/solana/bonding-curve-read.ts"
      provides: "BondingCurve PDA account deserialization and reserve reading"
      exports: ["readBondingCurveAccount", "deserializeBondingCurve"]
    - path: "lib/solana/trade.ts"
      provides: "buildAndSendBuy() and buildAndSendSell() transaction construction"
      exports: ["buildAndSendBuy", "buildAndSendSell"]
    - path: "lib/db/schema.ts"
      provides: "trade table definition"
      contains: "export const trade = pgTable"
    - path: "app/trade/[token]/actions.ts"
      provides: "executeBuy, executeSell, getQuote server actions"
      exports: ["executeBuy", "executeSell", "getQuote"]
  key_links:
    - from: "lib/solana/trade.ts"
      to: "lib/solana/bonding-curve-math.ts"
      via: "estimateBuy/estimateSell for minTokensOut/minSolOut calculation"
      pattern: "import.*bonding-curve-math"
    - from: "lib/solana/trade.ts"
      to: "lib/solana/bonding-curve-read.ts"
      via: "readBondingCurveAccount for current reserves"
      pattern: "import.*bonding-curve-read"
    - from: "app/trade/[token]/actions.ts"
      to: "lib/solana/trade.ts"
      via: "buildAndSendBuy/buildAndSendSell"
      pattern: "import.*lib/solana/trade"
    - from: "app/trade/[token]/actions.ts"
      to: "lib/db/schema.ts"
      via: "trade table insert for pending record"
      pattern: "import.*trade.*from.*schema"
---

<objective>
Create the bonding curve math library, account reader, buy/sell transaction builders, trade DB schema, and server actions for executing trades.

Purpose: This is the foundation of Phase 6. All trading UI, webhooks, charts, and history depend on these server-side primitives. The math must exactly match the on-chain Rust implementation.

Output: TypeScript bonding curve math module, PDA account deserializer, buy/sell transaction builders following existing @solana/kit pipe pattern, trade table in DB schema, and executeBuy/executeSell/getQuote server actions.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-token-trading/06-RESEARCH.md

@lib/solana/create-token.ts — Existing @solana/kit pipe pattern for transaction construction, PDA derivation, instruction encoding
@lib/solana/transfer.ts — Existing server-side signing and sending pattern
@lib/solana/keypair.ts — decryptPrivateKey, getEncryptionKey
@lib/db/schema.ts — Existing schema with creatorToken table (mintAddress, bondingCurveAddress)
@programs/baremint/src/math.rs — On-chain constant-product math (source of truth for TypeScript port)
@programs/baremint/src/instructions/buy.rs — Buy instruction accounts and logic
@programs/baremint/src/instructions/sell.rs — Sell instruction accounts and logic
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bonding curve math, account reader, and trade DB schema</name>
  <files>
    lib/solana/bonding-curve-math.ts
    lib/solana/bonding-curve-read.ts
    lib/db/schema.ts
  </files>
  <action>
**1. Create `lib/solana/bonding-curve-math.ts`** — TypeScript port of `programs/baremint/src/math.rs`:

Export these functions (all using BigInt, no floating point):
- `calculateBuyTokens(virtualSolReserves, virtualTokenReserves, solAmount)` — constant-product: `k = vSol * vToken; newVSol = vSol + solAmount; newVToken = k / newVSol; return vToken - newVToken`
- `calculateSellSol(virtualSolReserves, virtualTokenReserves, tokenAmount)` — constant-product: `k = vSol * vToken; newVToken = vToken + tokenAmount; newVSol = k / newVToken; return vSol - newVSol`
- `calculateFee(amount, feeBps)` — ceiling division: `(amount * BigInt(feeBps) + 9999n) / 10000n`
- `estimateBuy(solAmount, feeBps, virtualSol, virtualToken)` — Buy flow: fee deducted BEFORE curve calc. Returns `{ tokensOut, totalFee, platformFee, creatorFee, solIntoCurve }`. Platform fee = totalFee / 2n, creator fee = totalFee - platformFee.
- `estimateSell(tokenAmount, feeBps, virtualSol, virtualToken)` — Sell flow: fee deducted AFTER curve calc. Returns `{ netSol, grossSol, totalFee, platformFee, creatorFee }`.
- `calculatePricePerToken(virtualSolReserves, virtualTokenReserves)` — spot price as `{ priceNum: bigint, priceDenom: bigint }` (avoid floating point).

All return 0n for zero inputs. Use exact same rounding as Rust (floor division for curve, ceiling for fees).

**2. Create `lib/solana/bonding-curve-read.ts`** — Read and deserialize BondingCurve PDA:

Export:
- `deserializeBondingCurve(data: Uint8Array)` — Parse: skip 8-byte discriminator, then read fields in order: token_mint(32 bytes as Address), creator(32 bytes as Address), virtual_token_reserves(u64 LE), virtual_sol_reserves(u64 LE), real_token_reserves(u64 LE), real_sol_reserves(u64 LE), token_total_supply(u64 LE), burn_sol_price(u64 LE), platform_fees_accrued(u64 LE), creator_fees_accrued(u64 LE), bump(u8). Return typed object.
- `readBondingCurveAccount(mintAddress: string)` — Use `createSolanaRpc` with `getRpcUrl()` pattern from create-token.ts. Derive bonding_curve PDA using `["bonding_curve", mintAddressBytes]` seeds. Fetch account data via `rpc.getAccountInfo(bondingCurveAddress).send()`. Return deserialized data or throw if account not found.
- `readGlobalConfig()` — Derive global_config PDA with `["global_config"]` seed. Deserialize: skip 8-byte discriminator, then authority(32), fee_bps(u16 LE), platform_fee_vault(32). Return typed object.

Use `getAddressEncoder`, `getProgramDerivedAddress` from `@solana/kit`. Use PROGRAM_ID `FTAssMPiQ8EQUeJA4Rnu6c71maCrUCdnvGetWnVdTXTG`.

**3. Add `trade` table to `lib/db/schema.ts`** under a new "Token Trading tables (Phase 6)" section:

```typescript
export const trade = pgTable("trade", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull().references(() => user.id),
  creatorTokenId: text("creator_token_id").notNull().references(() => creatorToken.id),
  mintAddress: text("mint_address").notNull(),
  type: text("type").notNull(), // "buy" | "sell"
  solAmount: text("sol_amount").notNull(), // lamports as string
  tokenAmount: text("token_amount").notNull(), // raw token amount as string
  feeAmount: text("fee_amount").notNull(), // total fee in lamports as string
  pricePerToken: text("price_per_token"), // SOL per token ratio as string
  txSignature: text("tx_signature").notNull().unique(),
  status: text("status").notNull().default("pending"), // pending | confirmed | failed
  createdAt: timestamp("created_at").notNull().defaultNow(),
  confirmedAt: timestamp("confirmed_at"),
});
```

Run `npx drizzle-kit push` to sync schema.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no errors on the new files
- `npx drizzle-kit push` succeeds (trade table created)
- The math module's `calculateBuyTokens` and `calculateSellSol` handle edge cases: zero input returns 0n, large values don't overflow (BigInt handles arbitrary precision)
  </verify>
  <done>
- bonding-curve-math.ts exports calculateBuyTokens, calculateSellSol, calculateFee, estimateBuy, estimateSell, calculatePricePerToken
- bonding-curve-read.ts exports readBondingCurveAccount, readGlobalConfig, deserializeBondingCurve
- trade table exists in schema with all columns including txSignature unique constraint
- Schema pushed to database
  </done>
</task>

<task type="auto">
  <name>Task 2: Buy/sell transaction builders and server actions</name>
  <files>
    lib/solana/trade.ts
    app/trade/[token]/actions.ts
  </files>
  <action>
**1. Create `lib/solana/trade.ts`** — Buy and sell transaction builders following existing create-token.ts pattern:

Install new dependency first: `npm install @solana-program/token`

Export:
- `buildAndSendBuy(userId: string, mintAddress: string, solAmount: bigint, slippageBps: number)`:
  1. Get user wallet from DB, decrypt private key, create signer (same pattern as create-token.ts)
  2. Read bonding curve account via `readBondingCurveAccount(mintAddress)`
  3. Read global config via `readGlobalConfig()` to get `fee_bps`
  4. Calculate estimate via `estimateBuy(solAmount, feeBps, virtualSol, virtualToken)`
  5. Calculate `minTokensOut = tokensOut - (tokensOut * BigInt(slippageBps) / 10000n)`
  6. Derive PDAs: globalConfig, bondingCurve, curveTokenAccount (same seeds as create-token.ts)
  7. Derive buyer ATA using `findAssociatedTokenPda` from `@solana-program/token`
  8. Build instruction data: BUY_DISCRIMINATOR `[102, 6, 61, 18, 1, 218, 235, 234]` + u64 solAmount + u64 minTokensOut
  9. Build buy instruction with accounts (from buy.rs): buyer(signer,mut), global_config(readonly), bonding_curve(mut), curve_token_account(mut), buyer_token_account(mut), token_program(readonly), system_program(readonly)
  10. Build createAssociatedTokenIdempotent instruction via `@solana-program/token`
  11. Build transaction message via pipe: feePayer, blockhash, appendInstructions([createATA, buyInstruction])
  12. Sign and send via `sendTransaction`
  13. Return `{ signature, estimate }` where estimate includes tokensOut, totalFee, etc.

- `buildAndSendSell(userId: string, mintAddress: string, tokenAmount: bigint, slippageBps: number)`:
  Same pattern but:
  1. SELL_DISCRIMINATOR `[51, 230, 133, 164, 1, 127, 131, 173]` + u64 tokenAmount + u64 minSolOut
  2. Calculate estimate via `estimateSell` and `minSolOut = netSol - (netSol * BigInt(slippageBps) / 10000n)`
  3. Sell instruction accounts (from sell.rs): seller(signer,mut), global_config(readonly), bonding_curve(mut), curve_token_account(mut), seller_token_account(mut), token_program(readonly), system_program(readonly)
  4. No ATA creation needed for sell (seller already has tokens)

Use ASSOCIATED_TOKEN_PROGRAM_ADDRESS from `@solana-program/token` for ATA derivation.

**2. Create `app/trade/[token]/actions.ts`** — Server actions with "use server" directive:

- `getQuote(mintAddress: string, side: "buy" | "sell", amount: string)`:
  1. Validate input with zod (mintAddress non-empty, amount parseable to BigInt, side is buy|sell)
  2. Read bonding curve + global config
  3. Call estimateBuy or estimateSell
  4. Convert all BigInt values to strings before returning (BigInt not JSON-serializable)
  5. Return `{ tokensOut/netSol, totalFee, platformFee, creatorFee, pricePerToken, priceImpactBps }`
  6. Price impact = difference between spot price and execution price in bps

- `executeBuy(mintAddress: string, solAmount: string, slippageBps: number)`:
  1. Validate auth via `getSession()` (import from lib/auth)
  2. Validate input with zod
  3. Look up creatorToken by mintAddress to get creatorTokenId
  4. Call `buildAndSendBuy`
  5. Insert trade record with status "pending" using crypto.randomUUID() for id
  6. Return `{ success: true, signature, estimate (stringified BigInts) }` or `{ success: false, error: string }`

- `executeSell(mintAddress: string, tokenAmount: string, slippageBps: number)`:
  Same pattern as executeBuy but calls buildAndSendSell.

All BigInt values in return objects must be converted to string. Use try/catch and return error objects, not thrown errors.
  </action>
  <verify>
- `npx tsc --noEmit` passes with no errors
- Server actions file has `"use server"` directive at top
- All BigInt values are converted to string before being returned from server actions
- Both executeBuy and executeSell check for authenticated session
- Both insert a pending trade record into the database
  </verify>
  <done>
- lib/solana/trade.ts exports buildAndSendBuy and buildAndSendSell
- app/trade/[token]/actions.ts exports executeBuy, executeSell, getQuote as server actions
- Buy flow: creates ATA idempotently + builds buy instruction in single tx
- Sell flow: builds sell instruction with slippage protection
- Trade records persisted with pending status after tx submission
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes for all new and modified files
- `npx drizzle-kit push` succeeds
- The bonding curve math exactly mirrors the Rust implementation:
  - Buy: fee deducted before curve calc
  - Sell: fee deducted after curve calc
  - Fees use ceiling division: (amount * bps + 9999n) / 10000n
- Transaction construction follows existing create-token.ts pipe pattern
- Server actions validate auth and input before executing
</verification>

<success_criteria>
- Bonding curve math module produces correct estimates for buy and sell
- BondingCurve PDA can be read and deserialized from on-chain
- Buy transaction includes ATA creation + buy instruction in single tx
- Sell transaction includes sell instruction with slippage protection
- Trade table exists with txSignature unique constraint
- Server actions are properly authenticated and return stringified BigInts
</success_criteria>

<output>
After completion, create `.planning/phases/06-token-trading/06-01-SUMMARY.md`
</output>
