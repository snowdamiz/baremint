---
phase: 02-bonding-curve-smart-contract
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - programs/baremint/src/math.rs
  - programs/baremint/src/instructions/create_token.rs
  - programs/baremint/src/instructions/buy.rs
  - programs/baremint/src/instructions/sell.rs
  - programs/baremint/src/instructions/mod.rs
  - programs/baremint/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Curve math correctly calculates token output for SOL input and vice versa"
    - "An SPL token can be created with 1B supply, 90/10 distribution, and revoked mint authority"
    - "Tokens can be bought from the curve with correct pricing, fees, and slippage protection"
    - "Tokens can be sold back to the curve with correct SOL output, fees, and slippage protection"
    - "90-day cooldown between token launches is enforced on-chain"
  artifacts:
    - path: "programs/baremint/src/math.rs"
      provides: "Pure math functions for curve calculations and fee computation"
      contains: "pub fn calculate_buy_tokens"
    - path: "programs/baremint/src/instructions/create_token.rs"
      provides: "Token creation with mint, distribute, revoke authority, cooldown check"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/buy.rs"
      provides: "Buy tokens from curve with fee deduction and slippage check"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/sell.rs"
      provides: "Sell tokens back to curve with fee deduction and slippage check"
      contains: "pub fn handler"
  key_links:
    - from: "programs/baremint/src/instructions/buy.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_buy_tokens and calculate_fee calls"
      pattern: "math::calculate_buy_tokens"
    - from: "programs/baremint/src/instructions/sell.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_sell_sol and calculate_fee calls"
      pattern: "math::calculate_sell_sol"
    - from: "programs/baremint/src/instructions/create_token.rs"
      to: "programs/baremint/src/state/creator_profile.rs"
      via: "CreatorProfile PDA for 90-day cooldown check"
      pattern: "CooldownNotElapsed"
---

<objective>
Implement the core bonding curve math module and the three primary trading instructions: create_token, buy, and sell.

Purpose: This is the heart of the program -- token creation with anti-rug protections (mint revocation, 90-day cooldown) and the bonding curve trading engine with constant product pricing, fee collection, and slippage protection.
Output: Working create_token, buy, and sell instructions backed by tested curve math.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bonding-curve-smart-contract/02-CONTEXT.md
@.planning/phases/02-bonding-curve-smart-contract/02-RESEARCH.md
@.planning/phases/02-bonding-curve-smart-contract/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement curve math module and create_token instruction</name>
  <files>
    programs/baremint/src/math.rs
    programs/baremint/src/instructions/create_token.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create math.rs with pure functions (all using u128 intermediate math, checked arithmetic):

       `calculate_buy_tokens(virtual_sol_reserves: u64, virtual_token_reserves: u64, sol_amount: u64) -> Result<u64>`
       - Constant product formula: k = virtual_sol * virtual_token (as u128)
       - new_virtual_sol = virtual_sol + sol_amount
       - new_virtual_token = k / new_virtual_sol
       - tokens_out = virtual_token - new_virtual_token
       - Floor result (round down, protocol-favorable)
       - All operations use checked_mul, checked_add, checked_sub, checked_div with MathOverflow error

       `calculate_sell_sol(virtual_sol_reserves: u64, virtual_token_reserves: u64, token_amount: u64) -> Result<u64>`
       - Same constant product formula
       - new_virtual_token = virtual_token + token_amount
       - new_virtual_sol = k / new_virtual_token
       - sol_out = virtual_sol - new_virtual_sol
       - Floor result (round down, protocol-favorable)

       `calculate_fee(amount: u64, fee_bps: u16) -> Result<u64>`
       - fee = amount * fee_bps / 10_000 (u128 intermediate)
       - Ceiling: round UP fees (protocol-favorable). Use (amount * fee_bps + 9999) / 10000 pattern.

       `calculate_tokens_for_sol_value(virtual_sol_reserves: u64, virtual_token_reserves: u64, sol_value: u64) -> Result<u64>`
       - Used for burn-for-access: given a SOL value, how many tokens is that worth at current price?
       - tokens = sol_value * virtual_token_reserves / virtual_sol_reserves (u128 intermediate)
       - Ceiling: round UP tokens to burn (protocol-favorable)

       Add Rust unit tests in the same file using #[cfg(test)] mod tests:
       - Test buy with known values (e.g., 1 SOL into 1073M/30 SOL reserves)
       - Test sell symmetry (buy then sell same amount returns less SOL due to rounding)
       - Test fee calculation with various amounts and bps
       - Test overflow protection with max u64 values
       - Test zero-amount edge cases return 0 or error appropriately

    2. Create instructions/create_token.rs:

       Context struct `CreateToken`:
       - creator: Signer (payer, mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - creator_profile: Account<CreatorProfile> (init_if_needed, payer = creator, seeds = [b"creator_profile", creator.key().as_ref()], space = 8 + CreatorProfile::INIT_SPACE)
       - token_mint: Account<Mint> (init, payer = creator, mint::decimals = 6, mint::authority = bonding_curve)
       - bonding_curve: Account<BondingCurve> (init, payer = creator, seeds = [b"bonding_curve", token_mint.key().as_ref()], space = 8 + BondingCurve::INIT_SPACE)
       - curve_token_account: Account<TokenAccount> (init, payer = creator, token::mint = token_mint, token::authority = bonding_curve, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - curve_sol_vault: SystemAccount (seeds = [b"curve_vault", token_mint.key().as_ref()])
       - vesting_account: Account<VestingAccount> (init, payer = creator, seeds = [b"vesting", token_mint.key().as_ref()], space = 8 + VestingAccount::INIT_SPACE)
       - vesting_token_account: Account<TokenAccount> (init, payer = creator, token::mint = token_mint, token::authority = vesting_account, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - creator_fee_vault: SystemAccount (seeds = [b"creator_vault", token_mint.key().as_ref()])
       - token_program: Program<Token>
       - system_program: Program<System>
       - rent: Sysvar<Rent>

       Handler function `create_token(ctx, burn_sol_price: u64)`:
       a. Check 90-day cooldown: if creator_profile.last_token_launch_timestamp > 0, ensure clock.unix_timestamp - last_timestamp >= global_config.launch_cooldown_seconds. Error: CooldownNotElapsed
       b. Calculate supply: total = 1_000_000_000_000_000 (1B with 6 decimals). curve_amount = total * (10000 - creator_allocation_bps) / 10000. vesting_amount = total - curve_amount.
       c. Mint total supply to curve_token_account using CPI (mint_to with bonding_curve PDA signer seeds)
       d. Transfer vesting_amount from curve_token_account to vesting_token_account using CPI (transfer with bonding_curve PDA signer)
       e. Revoke mint authority: set_authority on token_mint, authority type MintTokens, new authority = None. Use bonding_curve PDA as current authority signer. This MUST happen in the same transaction -- if it fails, the whole tx reverts.
       f. Initialize BondingCurve state:
          - token_mint, creator
          - virtual_token_reserves = global_config.initial_virtual_token_reserves
          - virtual_sol_reserves = global_config.initial_virtual_sol_reserves
          - real_token_reserves = curve_amount
          - real_sol_reserves = 0
          - token_total_supply = total
          - burn_sol_price (from param)
          - bump from ctx.bumps.bonding_curve
       g. Initialize VestingAccount: creator, token_mint, total_allocation = vesting_amount, claimed_amount = 0, start_timestamp = clock.unix_timestamp, is_revoked = false, bump
       h. Update CreatorProfile: last_token_launch_timestamp = clock.unix_timestamp, tokens_launched += 1, creator = creator.key(), bump

    3. Wire into instructions/mod.rs and lib.rs program module.

    4. Run `anchor build` to verify compilation.
  </action>
  <verify>
    `anchor build` succeeds.
    `cargo test --manifest-path programs/baremint/Cargo.toml` passes all math unit tests.
    The IDL at target/idl/baremint.json contains the create_token instruction.
  </verify>
  <done>
    Curve math module has all pure functions with unit tests passing. create_token instruction mints 1B tokens, distributes 90/10, revokes mint authority, enforces 90-day cooldown, and initializes BondingCurve + VestingAccount + CreatorProfile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement buy and sell instructions</name>
  <files>
    programs/baremint/src/instructions/buy.rs
    programs/baremint/src/instructions/sell.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create instructions/buy.rs:

       Context struct `Buy`:
       - buyer: Signer (payer, mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>
       - curve_token_account: Account<TokenAccount> (mut, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - curve_sol_vault: SystemAccount (mut, seeds = [b"curve_vault", token_mint.key().as_ref()])
       - buyer_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = buyer)
         NOTE: Use init_if_needed for buyer_token_account so buyers don't need a pre-existing ATA. Or require them to create it beforehand -- simpler. Go with requiring pre-existing ATA (buyer creates it client-side). Use constraint: token::authority = buyer.
       - platform_vault: SystemAccount (mut, seeds = [b"platform_vault"])
       - creator_fee_vault: SystemAccount (mut, seeds = [b"creator_vault", token_mint.key().as_ref()])
       - token_program: Program<Token>
       - system_program: Program<System>

       Handler `buy(ctx, sol_amount: u64, min_tokens_out: u64)`:
       a. Calculate fees: total_fee = calculate_fee(sol_amount, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       b. sol_into_curve = sol_amount - total_fee
       c. tokens_out = calculate_buy_tokens(bonding_curve.virtual_sol_reserves, bonding_curve.virtual_token_reserves, sol_into_curve)
       d. Slippage check: require!(tokens_out >= min_tokens_out, SlippageExceeded)
       e. Check real_token_reserves >= tokens_out, error InsufficientReserves
       f. Transfer SOL from buyer to curve_sol_vault: system_program::transfer CPI (sol_into_curve)
       g. Transfer SOL from buyer to platform_vault: system_program::transfer CPI (platform_fee)
       h. Transfer SOL from buyer to creator_fee_vault: system_program::transfer CPI (creator_fee)
       i. Transfer tokens from curve_token_account to buyer_token_account: token::transfer CPI with bonding_curve PDA signer (tokens_out)
       j. Update bonding_curve state:
          - virtual_sol_reserves += sol_into_curve
          - virtual_token_reserves -= tokens_out
          - real_sol_reserves += sol_into_curve
          - real_token_reserves -= tokens_out

    2. Create instructions/sell.rs:

       Context struct `Sell`:
       - seller: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>
       - curve_token_account: Account<TokenAccount> (mut, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - curve_sol_vault: SystemAccount (mut, seeds = [b"curve_vault", token_mint.key().as_ref()])
       - seller_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = seller)
       - platform_vault: SystemAccount (mut, seeds = [b"platform_vault"])
       - creator_fee_vault: SystemAccount (mut, seeds = [b"creator_vault", token_mint.key().as_ref()])
       - token_program: Program<Token>
       - system_program: Program<System>

       Handler `sell(ctx, token_amount: u64, min_sol_out: u64)`:
       a. gross_sol_out = calculate_sell_sol(bonding_curve.virtual_sol_reserves, bonding_curve.virtual_token_reserves, token_amount)
       b. Calculate fees: total_fee = calculate_fee(gross_sol_out, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       c. net_sol_out = gross_sol_out - total_fee
       d. Slippage check: require!(net_sol_out >= min_sol_out, SlippageExceeded)
       e. Check real_sol_reserves >= gross_sol_out, error InsufficientReserves
       f. Transfer tokens from seller_token_account to curve_token_account: token::transfer CPI (token_amount, seller signs)
       g. Transfer SOL from curve_sol_vault to seller: Use PDA signer seeds for curve_sol_vault. Since curve_sol_vault is a SystemAccount PDA, transfer SOL by directly adjusting lamports (subtract from vault, add to seller) -- this is safe because the program owns the PDA. Use `**curve_sol_vault.try_borrow_mut_lamports()? -= net_sol_out` and `**seller.try_borrow_mut_lamports()? += net_sol_out` pattern. Alternatively, use invoke_signed with system_program::transfer from the vault PDA. The lamport manipulation approach is simpler for PDAs.
       h. Transfer fees from curve_sol_vault to platform_vault and creator_fee_vault using same lamport manipulation.
       i. Update bonding_curve state:
          - virtual_sol_reserves -= gross_sol_out
          - virtual_token_reserves += token_amount
          - real_sol_reserves -= gross_sol_out
          - real_token_reserves += token_amount

       IMPORTANT for SOL transfers from PDA: curve_sol_vault is a PDA owned by the system program. To transfer SOL OUT of a system-owned PDA, you need invoke_signed with system_program::transfer -- BUT system_program::transfer requires the source to be a signer, and PDAs can only sign via invoke_signed if the program owns them. Since the system program owns SystemAccount PDAs, you CANNOT use system_program::transfer from them.

       SOLUTION: Make curve_sol_vault a PDA owned by YOUR program instead of a SystemAccount. The simplest approach: Store SOL in the bonding_curve PDA itself (it's already program-owned). Add SOL to bonding_curve's lamports on buy, subtract on sell. This avoids a separate vault entirely. Alternatively, use a dedicated account that the program initializes (seeds + init with zero space, just to hold SOL). The cleanest approach for Anchor: use the bonding_curve account itself as the SOL vault by adding lamports to it via system_program::transfer (buyer -> bonding_curve PDA on buy), and subtracting lamports on sell since the program owns the bonding_curve PDA.

       REVISED APPROACH: Remove curve_sol_vault from all contexts. Store SOL directly in the bonding_curve PDA account. On buy: system_program::transfer from buyer to bonding_curve. On sell: subtract lamports from bonding_curve, add to seller (program owns this PDA). Same for fee vaults -- use platform_vault and creator_fee_vault as PDAs but the program must own them. Simplest: use separate PDA accounts initialized with #[account(init, space = 0, ...)] -- but Anchor requires at least 8 bytes for discriminator.

       FINAL APPROACH: Keep it simple. On buy, buyer sends ALL SOL (sol_amount) to bonding_curve PDA via system_program::transfer. Then the program distributes fees from bonding_curve PDA to platform/creator vaults (lamport manipulation since program owns the PDA). On sell, program sends SOL from bonding_curve PDA to seller and fee vaults (lamport manipulation). This means the bonding_curve PDA holds both reserves AND undistributed fees temporarily within the instruction, but by end of instruction, fees are moved to vaults.

       For fee vaults: They need to be PDAs that can accumulate SOL. Use UncheckedAccount with seeds constraints, and the program simply adds lamports to them. They don't need to be initialized as Anchor accounts -- just raw PDAs that hold SOL. Mark them with `/// CHECK: PDA validated by seeds` comment.

       Update Buy handler similarly: buyer transfers sol_amount to bonding_curve PDA, then program moves fees from bonding_curve to fee vault PDAs.

    3. Wire buy and sell into instructions/mod.rs and lib.rs.

    4. `anchor build` to verify.
  </action>
  <verify>
    `anchor build` succeeds.
    IDL contains buy instruction with (sol_amount: u64, min_tokens_out: u64) params.
    IDL contains sell instruction with (token_amount: u64, min_sol_out: u64) params.
    `cargo test --manifest-path programs/baremint/Cargo.toml` still passes all math tests.
  </verify>
  <done>
    Buy instruction: deducts 5% fee (2.5% platform, 2.5% creator), calculates tokens via constant product curve, checks slippage, transfers SOL and tokens, updates reserves. Sell instruction: calculates SOL output, deducts fees from output, checks slippage, transfers tokens back and SOL out, updates reserves. Both use bonding_curve PDA as SOL vault with lamport manipulation for outgoing transfers.
  </done>
</task>

</tasks>

<verification>
- `anchor build` succeeds with all four instructions (initialize, create_token, buy, sell)
- Rust unit tests for math.rs pass
- IDL contains all instructions with correct parameters
- Fee deduction happens before curve calculation on buy, after curve calculation on sell
- Slippage protection on both buy and sell
- 90-day cooldown enforced in create_token via CreatorProfile
- Mint authority revoked in create_token
</verification>

<success_criteria>
- Constant product curve math with u128 intermediate, checked arithmetic, protocol-favorable rounding
- create_token: 1B supply, 90/10 split, mint revocation, 90-day cooldown, CreatorProfile tracking
- buy: fee -> curve calc -> slippage check -> transfers -> state update
- sell: curve calc -> fee -> slippage check -> transfers -> state update
- All compiles and math unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-bonding-curve-smart-contract/02-02-SUMMARY.md`
</output>
