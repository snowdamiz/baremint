---
phase: 02-bonding-curve-smart-contract
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - programs/baremint/src/math.rs
  - programs/baremint/src/instructions/create_token.rs
  - programs/baremint/src/instructions/buy.rs
  - programs/baremint/src/instructions/sell.rs
  - programs/baremint/src/instructions/mod.rs
  - programs/baremint/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Curve math correctly calculates token output for SOL input and vice versa"
    - "An SPL token can be created with 1B supply, 90/10 distribution, and revoked mint authority"
    - "Tokens can be bought from the curve with correct pricing, fees accrued in bonding_curve PDA, and slippage protection"
    - "Tokens can be sold back to the curve with correct SOL output, fees accrued in bonding_curve PDA, and slippage protection"
    - "90-day cooldown between token launches is enforced on-chain"
  artifacts:
    - path: "programs/baremint/src/math.rs"
      provides: "Pure math functions for curve calculations and fee computation"
      contains: "pub fn calculate_buy_tokens"
    - path: "programs/baremint/src/instructions/create_token.rs"
      provides: "Token creation with mint, distribute, revoke authority, cooldown check"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/buy.rs"
      provides: "Buy tokens from curve with fee accrual and slippage check"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/sell.rs"
      provides: "Sell tokens back to curve with fee accrual and slippage check"
      contains: "pub fn handler"
  key_links:
    - from: "programs/baremint/src/instructions/buy.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_buy_tokens and calculate_fee calls"
      pattern: "math::calculate_buy_tokens"
    - from: "programs/baremint/src/instructions/sell.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_sell_sol and calculate_fee calls"
      pattern: "math::calculate_sell_sol"
    - from: "programs/baremint/src/instructions/buy.rs"
      to: "programs/baremint/src/state/bonding_curve.rs"
      via: "Fee accrual into platform_fees_accrued and creator_fees_accrued fields"
      pattern: "platform_fees_accrued|creator_fees_accrued"
    - from: "programs/baremint/src/instructions/create_token.rs"
      to: "programs/baremint/src/state/creator_profile.rs"
      via: "CreatorProfile PDA for 90-day cooldown check"
      pattern: "CooldownNotElapsed"
---

<objective>
Implement the core bonding curve math module and the three primary trading instructions: create_token, buy, and sell.

Purpose: This is the heart of the program -- token creation with anti-rug protections (mint revocation, 90-day cooldown) and the bonding curve trading engine with constant product pricing, fee accrual, and slippage protection.
Output: Working create_token, buy, and sell instructions backed by tested curve math. All SOL (reserves + fees) held in the bonding_curve PDA with fee amounts tracked via accrual fields.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bonding-curve-smart-contract/02-CONTEXT.md
@.planning/phases/02-bonding-curve-smart-contract/02-RESEARCH.md
@.planning/phases/02-bonding-curve-smart-contract/02-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement curve math module and create_token instruction</name>
  <files>
    programs/baremint/src/math.rs
    programs/baremint/src/instructions/create_token.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create math.rs with pure functions (all using u128 intermediate math, checked arithmetic):

       `calculate_buy_tokens(virtual_sol_reserves: u64, virtual_token_reserves: u64, sol_amount: u64) -> Result<u64>`
       - Constant product formula: k = virtual_sol * virtual_token (as u128)
       - new_virtual_sol = virtual_sol + sol_amount
       - new_virtual_token = k / new_virtual_sol
       - tokens_out = virtual_token - new_virtual_token
       - Floor result (round down, protocol-favorable)
       - All operations use checked_mul, checked_add, checked_sub, checked_div with MathOverflow error

       `calculate_sell_sol(virtual_sol_reserves: u64, virtual_token_reserves: u64, token_amount: u64) -> Result<u64>`
       - Same constant product formula
       - new_virtual_token = virtual_token + token_amount
       - new_virtual_sol = k / new_virtual_token
       - sol_out = virtual_sol - new_virtual_sol
       - Floor result (round down, protocol-favorable)

       `calculate_fee(amount: u64, fee_bps: u16) -> Result<u64>`
       - fee = amount * fee_bps / 10_000 (u128 intermediate)
       - Ceiling: round UP fees (protocol-favorable). Use (amount * fee_bps + 9999) / 10000 pattern.

       `calculate_tokens_for_sol_value(virtual_sol_reserves: u64, virtual_token_reserves: u64, sol_value: u64) -> Result<u64>`
       - Used for burn-for-access: given a SOL value, how many tokens is that worth at current price?
       - tokens = sol_value * virtual_token_reserves / virtual_sol_reserves (u128 intermediate)
       - Ceiling: round UP tokens to burn (protocol-favorable)

       Add Rust unit tests in the same file using #[cfg(test)] mod tests:
       - Test buy with known values (e.g., 1 SOL into 1073M/30 SOL reserves)
       - Test sell symmetry (buy then sell same amount returns less SOL due to rounding)
       - Test fee calculation with various amounts and bps
       - Test overflow protection with max u64 values
       - Test zero-amount edge cases return 0 or error appropriately

    2. Create instructions/create_token.rs:

       Context struct `CreateToken`:
       - creator: Signer (payer, mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - creator_profile: Account<CreatorProfile> (init_if_needed, payer = creator, seeds = [b"creator_profile", creator.key().as_ref()], space = 8 + CreatorProfile::INIT_SPACE)
       - token_mint: Account<Mint> (init, payer = creator, mint::decimals = 6, mint::authority = bonding_curve)
       - bonding_curve: Account<BondingCurve> (init, payer = creator, seeds = [b"bonding_curve", token_mint.key().as_ref()], space = 8 + BondingCurve::INIT_SPACE)
       - curve_token_account: Account<TokenAccount> (init, payer = creator, token::mint = token_mint, token::authority = bonding_curve, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - vesting_account: Account<VestingAccount> (init, payer = creator, seeds = [b"vesting", token_mint.key().as_ref()], space = 8 + VestingAccount::INIT_SPACE)
       - vesting_token_account: Account<TokenAccount> (init, payer = creator, token::mint = token_mint, token::authority = vesting_account, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - token_program: Program<Token>
       - system_program: Program<System>
       - rent: Sysvar<Rent>

       Handler function `create_token(ctx, burn_sol_price: u64)`:
       a. Check 90-day cooldown: if creator_profile.last_token_launch_timestamp > 0, ensure clock.unix_timestamp - last_timestamp >= global_config.launch_cooldown_seconds. Error: CooldownNotElapsed
       b. Calculate supply: total = 1_000_000_000_000_000 (1B with 6 decimals). curve_amount = total * (10000 - creator_allocation_bps) / 10000. vesting_amount = total - curve_amount.
       c. Mint total supply to curve_token_account using CPI (mint_to with bonding_curve PDA signer seeds)
       d. Transfer vesting_amount from curve_token_account to vesting_token_account using CPI (transfer with bonding_curve PDA signer)
       e. Revoke mint authority: set_authority on token_mint, authority type MintTokens, new authority = None. Use bonding_curve PDA as current authority signer. This MUST happen in the same transaction -- if it fails, the whole tx reverts.
       f. Initialize BondingCurve state:
          - token_mint, creator
          - virtual_token_reserves = global_config.initial_virtual_token_reserves
          - virtual_sol_reserves = global_config.initial_virtual_sol_reserves
          - real_token_reserves = curve_amount
          - real_sol_reserves = 0
          - token_total_supply = total
          - burn_sol_price (from param)
          - platform_fees_accrued = 0
          - creator_fees_accrued = 0
          - bump from ctx.bumps.bonding_curve
       g. Initialize VestingAccount: creator, token_mint, total_allocation = vesting_amount, claimed_amount = 0, start_timestamp = clock.unix_timestamp, is_revoked = false, bump
       h. Update CreatorProfile: last_token_launch_timestamp = clock.unix_timestamp, tokens_launched += 1, creator = creator.key(), bump

    3. Wire into instructions/mod.rs and lib.rs program module.

    4. Run `anchor build` to verify compilation.
  </action>
  <verify>
    `anchor build` succeeds.
    `cargo test --manifest-path programs/baremint/Cargo.toml` passes all math unit tests.
    The IDL at target/idl/baremint.json contains the create_token instruction.
  </verify>
  <done>
    Curve math module has all pure functions with unit tests passing. create_token instruction mints 1B tokens, distributes 90/10, revokes mint authority, enforces 90-day cooldown, and initializes BondingCurve (with platform_fees_accrued=0, creator_fees_accrued=0) + VestingAccount + CreatorProfile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement buy and sell instructions with fee accrual pattern</name>
  <files>
    programs/baremint/src/instructions/buy.rs
    programs/baremint/src/instructions/sell.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create instructions/buy.rs:

       ARCHITECTURE: All SOL is held in the bonding_curve PDA. There are NO separate platform_vault or creator_fee_vault accounts. Fees are tracked as accrual fields on the BondingCurve struct (platform_fees_accrued, creator_fees_accrued). Withdrawal instructions (Plan 02-03) will read these fields and transfer lamports out of the bonding_curve PDA.

       Context struct `Buy`:
       - buyer: Signer (payer, mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>
       - curve_token_account: Account<TokenAccount> (mut, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - buyer_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = buyer)
         NOTE: Require pre-existing ATA (buyer creates it client-side). Use constraint: token::authority = buyer.
       - token_program: Program<Token>
       - system_program: Program<System>

       Handler `buy(ctx, sol_amount: u64, min_tokens_out: u64)`:
       a. Calculate fees: total_fee = calculate_fee(sol_amount, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       b. sol_into_curve = sol_amount - total_fee
       c. tokens_out = calculate_buy_tokens(bonding_curve.virtual_sol_reserves, bonding_curve.virtual_token_reserves, sol_into_curve)
       d. Slippage check: require!(tokens_out >= min_tokens_out, SlippageExceeded)
       e. Check real_token_reserves >= tokens_out, error InsufficientReserves
       f. Transfer ALL sol_amount from buyer to bonding_curve PDA via system_program::transfer CPI. The bonding_curve PDA holds everything (reserves + fees).
       g. Transfer tokens from curve_token_account to buyer_token_account: token::transfer CPI with bonding_curve PDA signer (tokens_out)
       h. Update bonding_curve state:
          - virtual_sol_reserves += sol_into_curve
          - virtual_token_reserves -= tokens_out
          - real_sol_reserves += sol_into_curve
          - real_token_reserves -= tokens_out
          - platform_fees_accrued += platform_fee
          - creator_fees_accrued += creator_fee

    2. Create instructions/sell.rs:

       Context struct `Sell`:
       - seller: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>
       - curve_token_account: Account<TokenAccount> (mut, seeds = [b"curve_tokens", token_mint.key().as_ref()])
       - seller_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = seller)
       - token_program: Program<Token>
       - system_program: Program<System>

       Handler `sell(ctx, token_amount: u64, min_sol_out: u64)`:
       a. gross_sol_out = calculate_sell_sol(bonding_curve.virtual_sol_reserves, bonding_curve.virtual_token_reserves, token_amount)
       b. Calculate fees: total_fee = calculate_fee(gross_sol_out, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       c. net_sol_out = gross_sol_out - total_fee
       d. Slippage check: require!(net_sol_out >= min_sol_out, SlippageExceeded)
       e. Check real_sol_reserves >= gross_sol_out, error InsufficientReserves
       f. Transfer tokens from seller_token_account to curve_token_account: token::transfer CPI (token_amount, seller signs)
       g. Transfer net_sol_out from bonding_curve PDA to seller: Use lamport manipulation since the program owns the bonding_curve PDA. Subtract net_sol_out from bonding_curve lamports, add to seller lamports. Ensure bonding_curve retains enough for rent exemption.
       h. Update bonding_curve state:
          - virtual_sol_reserves -= gross_sol_out
          - virtual_token_reserves += token_amount
          - real_sol_reserves -= gross_sol_out
          - real_token_reserves += token_amount
          - platform_fees_accrued += platform_fee
          - creator_fees_accrued += creator_fee

       IMPORTANT: On sell, gross_sol_out comes out of reserves but fees stay in the PDA. The net effect: PDA loses net_sol_out lamports (sent to seller). real_sol_reserves decreases by gross_sol_out. Fee accrual fields increase by their respective amounts. The lamport balance reconciles: reserves_lamports = real_sol_reserves, fee_lamports = platform_fees_accrued + creator_fees_accrued, total = real_sol_reserves + accrued_fees + rent_exempt.

    3. Wire buy and sell into instructions/mod.rs and lib.rs.

    4. `anchor build` to verify.
  </action>
  <verify>
    `anchor build` succeeds.
    IDL contains buy instruction with (sol_amount: u64, min_tokens_out: u64) params.
    IDL contains sell instruction with (token_amount: u64, min_sol_out: u64) params.
    Buy and Sell contexts do NOT reference platform_vault or creator_fee_vault -- only bonding_curve PDA.
    `cargo test --manifest-path programs/baremint/Cargo.toml` still passes all math tests.
  </verify>
  <done>
    Buy instruction: deducts 5% fee (2.5% platform, 2.5% creator) tracked as accrual fields on bonding_curve, calculates tokens via constant product curve, checks slippage, transfers all SOL into bonding_curve PDA, transfers tokens out. Sell instruction: calculates SOL output, deducts fees tracked as accrual fields, checks slippage, transfers tokens back, sends net SOL to seller via lamport manipulation. No separate fee vault accounts -- all SOL in bonding_curve PDA.
  </done>
</task>

</tasks>

<verification>
- `anchor build` succeeds with all four instructions (initialize, create_token, buy, sell)
- Rust unit tests for math.rs pass
- IDL contains all instructions with correct parameters
- Fee accrual pattern used: platform_fees_accrued and creator_fees_accrued updated on every buy and sell
- No separate platform_vault or creator_fee_vault PDAs in buy/sell contexts
- Fee deduction happens before curve calculation on buy, after curve calculation on sell
- Slippage protection on both buy and sell
- 90-day cooldown enforced in create_token via CreatorProfile
- Mint authority revoked in create_token
</verification>

<success_criteria>
- Constant product curve math with u128 intermediate, checked arithmetic, protocol-favorable rounding
- create_token: 1B supply, 90/10 split, mint revocation, 90-day cooldown, CreatorProfile tracking
- buy: fee -> curve calc -> slippage check -> transfers -> state update with fee accrual
- sell: curve calc -> fee -> slippage check -> transfers -> state update with fee accrual
- All SOL in bonding_curve PDA, fees tracked via accrual fields
- All compiles and math unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-bonding-curve-smart-contract/02-02-SUMMARY.md`
</output>
