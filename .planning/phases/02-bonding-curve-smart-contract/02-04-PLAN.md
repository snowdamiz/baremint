---
phase: 02-bonding-curve-smart-contract
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - tests/setup.ts
  - tests/initialize.test.ts
  - tests/create_token.test.ts
  - tests/buy_sell.test.ts
  - tests/burn.test.ts
  - tests/vesting.test.ts
  - tests/fees.test.ts
  - jest.config.ts
  - package.json
autonomous: false

must_haves:
  truths:
    - "GlobalConfig initializes with correct parameters and rejects invalid fee config"
    - "Token creation mints 1B tokens, distributes 90/10, revokes mint authority, enforces 90-day cooldown"
    - "Buying tokens returns correct amount based on constant product formula with fees accrued in bonding_curve PDA"
    - "Selling tokens returns correct SOL based on constant product formula with fees accrued in bonding_curve PDA"
    - "Slippage protection reverts transactions when price moves beyond tolerance"
    - "Burn-for-access destroys correct token amount, no SOL returned to viewer (deflationary), fees extracted from reserves"
    - "Vesting cliff blocks claims before 30 days, allows weekly claims after"
    - "Fee withdrawal sends accrued fees from bonding_curve PDA to authority/creator"
    - "Program deploys to devnet and all tests pass against devnet"
  artifacts:
    - path: "tests/setup.ts"
      provides: "Bankrun test helpers, keypair generation, common setup"
      contains: "startAnchor"
    - path: "tests/buy_sell.test.ts"
      provides: "Trading tests with curve math verification and fee accrual checks"
      contains: "describe.*buy"
    - path: "tests/vesting.test.ts"
      provides: "Vesting tests with time manipulation"
      contains: "setClock"
  key_links:
    - from: "tests/setup.ts"
      to: "target/idl/baremint.json"
      via: "IDL import for program client"
      pattern: "IDL|idl"
    - from: "tests/buy_sell.test.ts"
      to: "programs/baremint/src/math.rs"
      via: "TypeScript mirrors of curve math for expected value assertions"
      pattern: "calculate.*tokens|calculate.*sol"
---

<objective>
Build a comprehensive test suite using anchor-bankrun and deploy the program to Solana devnet.

Purpose: Validates all program behavior before devnet deployment. Tests cover happy paths, edge cases, security constraints, and the full lifecycle of token creation through trading, burning, vesting, and fee withdrawal.
Output: All tests passing, program deployed to devnet with verified program ID.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bonding-curve-smart-contract/02-CONTEXT.md
@.planning/phases/02-bonding-curve-smart-contract/02-RESEARCH.md
@.planning/phases/02-bonding-curve-smart-contract/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Test setup, initialize, create_token, and buy/sell tests</name>
  <files>
    tests/setup.ts
    tests/initialize.test.ts
    tests/create_token.test.ts
    tests/buy_sell.test.ts
    jest.config.ts
    package.json
  </files>
  <action>
    1. Create jest.config.ts for the Anchor test suite:
       - preset: "ts-jest"
       - testEnvironment: "node"
       - testMatch: ["**/tests/**/*.test.ts"]
       - transform: ts-jest
       - testTimeout: 30000 (bankrun tests are fast but give headroom)
       - NOTE: This must NOT interfere with any existing Jest config for the Next.js app. If there's already a jest.config at root, create a separate jest.config.anchor.ts and add an npm script "test:anchor" that uses --config jest.config.anchor.ts.

    2. Add npm script to package.json: "test:anchor": "jest --config jest.config.anchor.ts --forceExit"

    3. Create tests/setup.ts with shared helpers:
       - startAnchor helper that starts bankrun with the program
       - Helper to create and initialize GlobalConfig with default parameters:
         - fee_bps: 500, platform_fee_bps: 250, creator_fee_bps: 250
         - initial_virtual_token_reserves: 1_073_000_000_000_000 (1.073B with 6 decimals)
         - initial_virtual_sol_reserves: 30_000_000_000 (30 SOL in lamports)
       - Helper to airdrop SOL to test accounts
       - Helper to create associated token accounts
       - TypeScript mirror functions of the Rust math for expected value assertions:
         - calculateBuyTokens(virtualSol, virtualToken, solAmount) -> bigint
         - calculateSellSol(virtualSol, virtualToken, tokenAmount) -> bigint
         - calculateFee(amount, feeBps) -> bigint
         - All using BigInt for precision
       - Common constants: TOTAL_SUPPLY, LAMPORTS_PER_SOL, etc.

    4. Create tests/initialize.test.ts:
       - Test: initializes GlobalConfig with valid params -> all fields set correctly
       - Test: rejects invalid fee config (platform + creator != total)
       - Test: rejects fee_bps > 1000
       - Test: rejects zero virtual reserves
       - Test: rejects re-initialization (PDA already exists)

    5. Create tests/create_token.test.ts:
       - Test: creates token successfully -> 1B total supply, 900M in curve, 100M in vesting
       - Test: mint authority is None after creation (query mint account, verify mint_authority is null)
       - Test: BondingCurve state has correct initial reserves and platform_fees_accrued=0, creator_fees_accrued=0
       - Test: VestingAccount has correct allocation and start timestamp
       - Test: CreatorProfile records launch timestamp and token count
       - Test: second token launch within 90 days fails with CooldownNotElapsed
       - Test: second token launch after 90 days succeeds (use bankrun time manipulation to advance clock)
       - Test: burn_sol_price is stored correctly (test with 0 and non-zero values)

    6. Create tests/buy_sell.test.ts:
       - Setup: initialize config, create token, fund buyer with SOL

       Buy tests:
       - Test: buy with 1 SOL -> receives expected tokens (calculate expected with TS mirror, verify actual matches within 1 token tolerance for rounding)
       - Test: buy deducts 5% fee (verify bonding_curve.platform_fees_accrued and creator_fees_accrued increase correctly)
       - Test: all SOL goes into bonding_curve PDA (no separate vault accounts)
       - Test: buy with slippage protection -> passes when min_tokens_out is met
       - Test: buy fails when min_tokens_out exceeds actual output (SlippageExceeded)
       - Test: buy fails with 0 SOL (should fail gracefully)
       - Test: buy updates virtual and real reserves correctly
       - Test: multiple sequential buys increase price (second buy gets fewer tokens per SOL)

       Sell tests:
       - Test: sell tokens -> receives expected SOL minus fees
       - Test: sell deducts 5% fee tracked in accrual fields
       - Test: sell with slippage protection -> passes when min_sol_out is met
       - Test: sell fails when min_sol_out exceeds actual output
       - Test: sell fails when trying to sell more tokens than owned
       - Test: sell updates reserves correctly
       - Test: round-trip (buy then sell same tokens) returns less SOL than invested (due to fees + rounding)

       Price curve tests:
       - Test: after large buy, price is higher than initial price
       - Test: after buy + sell back to original amounts, reserves are approximately restored (minus fees)
  </action>
  <verify>
    `npm run test:anchor -- --testPathPattern="initialize|create_token|buy_sell"` -- all tests pass.
    At least 20 test cases pass across the three test files.
  </verify>
  <done>
    Test infrastructure established with bankrun, TS math mirrors, and shared helpers. Initialize tests verify config setup and validation. Create_token tests verify supply distribution, mint revocation, fee accrual fields initialized to 0, and 90-day cooldown. Buy/sell tests verify curve math, fee accrual into bonding_curve PDA fields, slippage protection, and reserve tracking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Burn, vesting, fee tests and devnet deployment</name>
  <files>
    tests/burn.test.ts
    tests/vesting.test.ts
    tests/fees.test.ts
  </files>
  <action>
    1. Create tests/burn.test.ts:
       - Setup: initialize, create token (with burn_sol_price = 0.1 SOL = 100_000_000 lamports), fund viewer, buy tokens for viewer
       - Test: burn_for_access destroys correct number of tokens based on SOL price
       - Test: burn_for_access is deflationary -- no SOL returned to viewer, only tokens burned
       - Test: burn_for_access extracts fee from curve reserves into bonding_curve fee accrual fields
       - Test: burn_for_access fails when burn_sol_price is 0 (BurnDisabled)
       - Test: burn_for_access fails when viewer has insufficient tokens
       - Test: after burn, token total supply decreases (deflationary)
       - Test: after burn, remaining token holders benefit (price per token is effectively higher because SOL stays but tokens are gone)
       - Test: fees are correctly split between platform and creator accrued amounts

    2. Create tests/vesting.test.ts:
       - Setup: initialize, create token, use bankrun clock manipulation for time advancement
       - Test: claim_vested fails before 30-day cliff (VestingCliffNotReached)
       - Test: claim_vested at exactly 30 days (cliff edge) -> should be claimable (first weekly window)
       - Test: claim_vested at day 37 (1 week after cliff) -> second weekly window of tokens
       - Test: claim_vested at day 90 (full vest complete) -> all remaining tokens claimable
       - Test: claim_vested after full vest -> VestingFullyClaimed error
       - Test: weekly windows are correct -> claim at day 33 (3 days after cliff) gets same as day 30 (snapped to weekly boundary)
       - Test: revoke_vesting burns unvested tokens
       - Test: revoke_vesting only callable by global_config authority
       - Test: claim_vested after revocation fails (VestingRevoked)
       - Test: revoke_vesting is idempotent (second call returns Ok without burning more)

       Time manipulation pattern:
       ```typescript
       const currentClock = await context.banksClient.getClock();
       context.setClock({
           ...currentClock,
           unixTimestamp: BigInt(currentClock.unixTimestamp) + BigInt(30 * 24 * 60 * 60),
       });
       ```

    3. Create tests/fees.test.ts:
       - Setup: initialize, create token, execute some buys and sells to accumulate fees
       - Test: withdraw_platform_fees sends correct SOL from bonding_curve PDA to authority
       - Test: withdraw_platform_fees resets platform_fees_accrued to 0
       - Test: withdraw_platform_fees fails for non-authority (Unauthorized)
       - Test: withdraw_creator_fees sends correct SOL from bonding_curve PDA to creator
       - Test: withdraw_creator_fees fails for non-creator (Unauthorized)
       - Test: fees accumulate correctly across multiple trades (buy, sell, buy, sell -> verify totals in accrual fields)
       - Test: bonding_curve retains rent-exempt lamports after fee withdrawal

    4. Run the complete test suite: `npm run test:anchor`

    5. Fix any test failures -- iterate until all tests pass.

    6. Deploy to devnet:
       a. Ensure Solana CLI is configured: `solana config set --url devnet`
       b. Ensure deployer wallet has devnet SOL: `solana airdrop 5` (may need multiple airdrops)
       c. Build for devnet: `anchor build`
       d. Deploy: `anchor deploy --provider.cluster devnet`
       e. Record the deployed program ID
       f. Verify deployment: `solana program show <PROGRAM_ID> --url devnet`

    7. If devnet deployment fails due to SOL or rate limits, document the steps needed and mark as ready for deployment. The test suite passing locally is the critical gate.
  </action>
  <verify>
    `npm run test:anchor` -- ALL tests pass (burn, vesting, fees, plus previous tests).
    Total test count is at least 35 across all test files.
    Program deployed to devnet (or deployment steps documented if rate-limited).
    `solana program show <PROGRAM_ID> --url devnet` confirms deployment (if deployed).
  </verify>
  <done>
    Burn tests verify deflationary mechanics (no SOL returned to viewer), fee extraction into accrual fields, and SOL-denominated pricing. Vesting tests verify 30-day cliff, weekly windows, full vest, and revocation with time manipulation. Fee tests verify accumulation in bonding_curve PDA fields and withdrawal for both platform and creator. Program deployed to devnet with verified program ID. All phase success criteria met.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Anchor program with 9 instructions (initialize, create_token, buy, sell, burn_for_access, claim_vested, withdraw_platform_fees, withdraw_creator_fees, revoke_vesting) and comprehensive test suite covering all trading, burn, vesting, and fee functionality.</what-built>
  <how-to-verify>
    1. Run `npm run test:anchor` and verify all tests pass
    2. Review test output for coverage of key scenarios:
       - Token creation with mint revocation
       - Buy/sell with correct pricing and fee accrual in bonding_curve PDA
       - Burn-for-access: deflationary, no SOL returned to viewer, fees extracted from reserves
       - Vesting cliff and weekly claim windows
       - Fee accumulation in bonding_curve fields and withdrawal
    3. If deployed to devnet, verify program ID with `solana program show <PROGRAM_ID> --url devnet`
    4. Review the program ID is correct in both lib.rs and Anchor.toml
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
- All test files exist and pass: initialize, create_token, buy_sell, burn, vesting, fees
- Test count >= 35 total assertions
- Program builds cleanly with `anchor build`
- Devnet deployment completed (or documented)
- Phase 2 success criteria verified:
  1. SPL token created on devnet with bonding curve PDA holding all SOL (reserves + fees)
  2. Tokens bought/sold through curve with correct pricing, fee accrual, and slippage protection
  3. Burning tokens for content access is deflationary -- tokens destroyed, no SOL returned to viewer, fees extracted from reserves
  4. Creator vesting enforces 30-day cliff and 60-day linear vest
  5. Platform and creator fees accrued in bonding_curve PDA on every trade and burn, withdrawable by authorized parties
</verification>

<success_criteria>
- 35+ test cases passing across all test files
- Zero test failures
- Program deployed to devnet with confirmed program ID
- All 5 phase success criteria from ROADMAP.md validated by tests
- SAFE-01 (vesting enforcement) verified by vesting tests
- SAFE-02 (90-day cooldown) verified by create_token tests
</success_criteria>

<output>
After completion, create `.planning/phases/02-bonding-curve-smart-contract/02-04-SUMMARY.md`
</output>
