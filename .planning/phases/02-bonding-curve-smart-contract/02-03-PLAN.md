---
phase: 02-bonding-curve-smart-contract
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - programs/baremint/src/instructions/burn_access.rs
  - programs/baremint/src/instructions/claim_vested.rs
  - programs/baremint/src/instructions/withdraw_fees.rs
  - programs/baremint/src/instructions/revoke_vesting.rs
  - programs/baremint/src/instructions/mod.rs
  - programs/baremint/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Burning tokens for content access destroys the correct token amount based on SOL-denominated price"
    - "Burn fees are deducted from curve reserves and sent to fee vaults"
    - "Creator cannot claim vested tokens before 30-day cliff"
    - "Creator can claim vested tokens in weekly windows after cliff"
    - "Creator and platform can withdraw accumulated fees from their vaults"
    - "Admin can revoke unvested tokens on creator ban (tokens burned, deflationary)"
  artifacts:
    - path: "programs/baremint/src/instructions/burn_access.rs"
      provides: "Burn-for-access instruction with SOL-denominated pricing"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/claim_vested.rs"
      provides: "Weekly vesting claim with 30-day cliff enforcement"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/withdraw_fees.rs"
      provides: "Fee withdrawal for platform and creator vaults"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/revoke_vesting.rs"
      provides: "Admin revoke vesting on creator ban"
      contains: "pub fn handler"
  key_links:
    - from: "programs/baremint/src/instructions/burn_access.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_tokens_for_sol_value for token amount calculation"
      pattern: "math::calculate_tokens_for_sol_value"
    - from: "programs/baremint/src/instructions/claim_vested.rs"
      to: "programs/baremint/src/state/vesting.rs"
      via: "VestingAccount state for cliff and claim tracking"
      pattern: "vesting_account\\.claimed_amount"
    - from: "programs/baremint/src/instructions/revoke_vesting.rs"
      to: "programs/baremint/src/state/global_config.rs"
      via: "GlobalConfig authority check for admin-only access"
      pattern: "global_config\\.authority"
---

<objective>
Implement the remaining four instructions: burn_for_access, claim_vested, withdraw_fees, and revoke_vesting.

Purpose: Completes the program's instruction set -- burn mechanics for content access (deflationary), creator vesting with cliff/linear schedule, fee withdrawal for both platform and creators, and admin revocation for creator bans.
Output: All 8 program instructions compile and are ready for integration testing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bonding-curve-smart-contract/02-CONTEXT.md
@.planning/phases/02-bonding-curve-smart-contract/02-RESEARCH.md
@.planning/phases/02-bonding-curve-smart-contract/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement burn_for_access and withdraw_fees instructions</name>
  <files>
    programs/baremint/src/instructions/burn_access.rs
    programs/baremint/src/instructions/withdraw_fees.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create instructions/burn_access.rs:

       Context struct `BurnAccess`:
       - viewer: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint> (mut -- needed for burn which reduces supply)
       - viewer_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = viewer)
       - platform_vault: UncheckedAccount (mut, seeds = [b"platform_vault"]) -- receives platform fee portion
       - creator_fee_vault: UncheckedAccount (mut, seeds = [b"creator_vault", token_mint.key().as_ref()])
       - token_program: Program<Token>
       - system_program: Program<System>

       Handler `burn_for_access(ctx)`:
       a. Check burn_sol_price > 0, else error BurnDisabled
       b. Calculate tokens to burn: tokens_to_burn = calculate_tokens_for_sol_value(virtual_sol_reserves, virtual_token_reserves, burn_sol_price). This gives the number of tokens worth burn_sol_price SOL at current curve price.
       c. Check viewer has enough tokens: viewer_token_account.amount >= tokens_to_burn, error InsufficientTokens
       d. Calculate the SOL-equivalent value of burned tokens for fee purposes: sol_equivalent = burn_sol_price (this IS the SOL value by definition)
       e. Calculate fees from the SOL equivalent: total_fee = calculate_fee(sol_equivalent, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       f. Burn tokens from viewer's account: token::burn CPI (viewer signs, tokens_to_burn amount)
       g. Move fees from bonding_curve PDA to fee vaults (lamport manipulation -- subtract from bonding_curve, add to platform_vault and creator_fee_vault). The bonding_curve holds SOL reserves, so we're taking fees FROM the reserves.
       h. Update bonding_curve state:
          - virtual_token_reserves += tokens_to_burn (tokens removed from circulation increase virtual reserves -- this is debatable, see note)

          NOTE ON BURN CURVE MECHANICS: When tokens are burned (destroyed), they leave circulation. The SOL-equivalent stays in reserves minus fees. The correct curve update depends on the economic model:
          - Option A: Increase virtual_token_reserves (burned tokens "return" to the curve conceptually) -- makes price drop slightly
          - Option B: Leave virtual reserves unchanged -- SOL per remaining token increases (bullish for holders)
          - Option C: Decrease both virtual_token and virtual_sol proportionally

          Per CONTEXT.md: "Remaining 95% of SOL-equivalent stays in curve reserves, benefiting remaining holders." This means the SOL stays but tokens are gone = price goes UP. So do NOT add tokens back to virtual reserves. The reserves stay the same, but real_token_reserves decreases (fewer tokens exist), and the virtual reserves stay unchanged (price is now higher because same SOL backs fewer tokens effectively).

          CORRECT UPDATE:
          - real_token_reserves -= tokens_to_burn (fewer real tokens in circulation)
          - real_sol_reserves -= total_fee (fees extracted from reserves)
          - virtual_sol_reserves -= total_fee (fees reduce the SOL in the curve)
          - virtual_token_reserves stays UNCHANGED (tokens burned, not returned to curve)
          - token_total_supply -= tokens_to_burn (track total supply decrease)

       i. Emit an event or log for off-chain indexing (optional, can add later)

    2. Create instructions/withdraw_fees.rs:

       Context struct `WithdrawFees`:
       - withdrawer: Signer (mut) -- could be platform authority or creator
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - fee_vault: UncheckedAccount (mut) -- either platform_vault or creator_vault PDA
         NOTE: This instruction needs to handle BOTH platform and creator withdrawals. Two approaches:
         a. Two separate instructions (withdraw_platform_fees, withdraw_creator_fees)
         b. One instruction with a flag

         Go with two separate instructions for clarity and security:

       REVISED: Create TWO handlers in the same file:

       Context struct `WithdrawPlatformFees`:
       - authority: Signer (mut) -- must match global_config.authority
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"], constraint = authority.key() == global_config.authority @ ErrorCode::Unauthorized)
       - platform_vault: UncheckedAccount (mut, seeds = [b"platform_vault"])
       - system_program: Program<System>

       Handler `withdraw_platform_fees(ctx)`:
       a. Calculate withdrawable amount: platform_vault.lamports() minus rent-exempt minimum (or just leave min lamports to keep account alive -- use a minimum of 890_880 lamports which is rent-exempt for 0 data bytes, or simply withdraw all above rent-exempt minimum)
       b. Transfer all SOL above rent-exempt minimum from platform_vault to authority via lamport manipulation (program can do this because... wait -- platform_vault is a system-owned PDA, program doesn't own it).

       PROBLEM: Same issue as sell -- can't manipulate lamports of accounts the program doesn't own.

       SOLUTION: Make fee vaults program-owned PDAs. Initialize them with the program as owner. The simplest Anchor pattern: create a zero-data PDA account owned by the program. Use `#[account(init, space = 8, ...)]` (8 bytes for Anchor discriminator). But then they need a struct.

       SIMPLER SOLUTION: Just store fee balances as fields on existing program-owned accounts. Add `platform_fees_accumulated: u64` to GlobalConfig and `creator_fees_accumulated: u64` to BondingCurve. Fees are tracked as balances, and SOL is held in the respective PDA accounts. On withdrawal, the program (which owns these PDAs) can manipulate lamports.

       SIMPLEST APPROACH: Store all SOL in the bonding_curve PDA for trading, and track fee amounts as fields. On fee withdrawal, subtract from the bonding_curve's lamports and send to the withdrawer.

       ACTUALLY, THE CLEANEST APPROACH: Since the bonding_curve PDA is owned by the program, store fees there as tracked balances. Add two fields to BondingCurve: `platform_fees_accrued: u64` and `creator_fees_accrued: u64`. All SOL (reserves + fees) lives in the bonding_curve PDA. Withdrawal subtracts from accrued fees and moves lamports out.

       BUT this means platform fees are scattered across all bonding curves. Platform needs to withdraw from each curve individually. This is fine for MVP.

       REVISED BondingCurve state (this will require updating the struct from Plan 02):
       Add fields: `platform_fees_accrued: u64` and `creator_fees_accrued: u64`

       Update the BondingCurve struct in state/bonding_curve.rs to include these two u64 fields.

       Context struct `WithdrawPlatformFees`:
       - authority: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"], constraint = authority.key() == global_config.authority @ Unauthorized)
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>
       - system_program: Program<System>

       Handler: Transfer platform_fees_accrued lamports from bonding_curve to authority. Set platform_fees_accrued = 0. Use lamport manipulation (program owns bonding_curve PDA).

       Context struct `WithdrawCreatorFees`:
       - creator: Signer (mut)
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()], constraint = creator.key() == bonding_curve.creator @ Unauthorized)
       - token_mint: Account<Mint>
       - system_program: Program<System>

       Handler: Transfer creator_fees_accrued lamports from bonding_curve to creator. Set creator_fees_accrued = 0.

       IMPORTANT: When manipulating lamports on program-owned accounts, ensure the account retains enough for rent exemption. Calculate: let rent_exempt = Rent::get()?.minimum_balance(bonding_curve_account_info.data_len()). Ensure remaining lamports >= rent_exempt.

    3. UPDATE bonding_curve.rs state struct to add platform_fees_accrued and creator_fees_accrued fields.

    4. UPDATE buy.rs and sell.rs handlers (from Plan 02) to accumulate fees into bonding_curve.platform_fees_accrued and bonding_curve.creator_fees_accrued instead of transferring to separate vault accounts. Remove platform_vault and creator_fee_vault from Buy and Sell contexts. All SOL flows into bonding_curve PDA on buy (full sol_amount). On sell, SOL comes out of bonding_curve (net_sol_out to seller). Fees stay in the PDA tracked by the accrued fields.

    Similarly for burn_access: fees tracked in bonding_curve's accrued fields, no separate fee vault transfers needed.

    5. Wire all new instructions into mod.rs and lib.rs.

    6. `anchor build` to verify.
  </action>
  <verify>
    `anchor build` succeeds with all instructions.
    IDL contains burn_for_access, withdraw_platform_fees, withdraw_creator_fees instructions.
    BondingCurve struct in IDL includes platform_fees_accrued and creator_fees_accrued fields.
    `cargo test --manifest-path programs/baremint/Cargo.toml` still passes math tests.
  </verify>
  <done>
    burn_for_access: calculates tokens from SOL-denominated price, burns tokens (deflationary), deducts fees from reserves, benefits remaining holders. withdraw_platform_fees: authority withdraws accrued platform fees. withdraw_creator_fees: creator withdraws accrued creator fees. All SOL managed via bonding_curve PDA with lamport manipulation. Buy/sell updated to use fee accrual pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement claim_vested and revoke_vesting instructions</name>
  <files>
    programs/baremint/src/instructions/claim_vested.rs
    programs/baremint/src/instructions/revoke_vesting.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create instructions/claim_vested.rs:

       Context struct `ClaimVested`:
       - creator: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - vesting_account: Account<VestingAccount> (mut, seeds = [b"vesting", token_mint.key().as_ref()], constraint = creator.key() == vesting_account.creator @ Unauthorized)
       - token_mint: Account<Mint>
       - vesting_token_account: Account<TokenAccount> (mut, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - creator_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = creator)
       - token_program: Program<Token>

       Handler `claim_vested(ctx)`:
       a. Check is_revoked == false, error VestingRevoked
       b. Get current_time from Clock::get()?.unix_timestamp
       c. Calculate claimable amount using the vesting math:
          - cliff_end = start_timestamp + vesting_cliff_seconds
          - If current_time < cliff_end, error VestingCliffNotReached
          - elapsed_since_cliff = min(current_time - cliff_end, vesting_duration_seconds)
          - Snap to weekly windows: weeks_elapsed = elapsed_since_cliff / vesting_claim_interval_seconds
          - snapped_elapsed = weeks_elapsed * vesting_claim_interval_seconds
          - total_vested = total_allocation * snapped_elapsed / vesting_duration_seconds (u128 intermediate)
          - claimable = total_vested - claimed_amount
          - If claimable == 0, error VestingFullyClaimed (or just return Ok(()) -- prefer error so client knows nothing happened)
       d. Transfer claimable tokens from vesting_token_account to creator_token_account: token::transfer CPI with vesting_account PDA signer seeds
       e. Update vesting_account.claimed_amount += claimable

    2. Create instructions/revoke_vesting.rs:

       Context struct `RevokeVesting`:
       - authority: Signer (mut) -- must be global_config.authority
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"], constraint = authority.key() == global_config.authority @ Unauthorized)
       - vesting_account: Account<VestingAccount> (mut, seeds = [b"vesting", token_mint.key().as_ref()])
       - token_mint: Account<Mint> (mut -- needed for burn)
       - vesting_token_account: Account<TokenAccount> (mut, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_program: Program<Token>

       Handler `revoke_vesting(ctx)`:
       a. Check vesting_account.is_revoked == false (idempotent -- if already revoked, just return Ok)
       b. Calculate unvested amount: unvested = total_allocation - claimed_amount
       c. Burn unvested tokens from vesting_token_account: token::burn CPI with vesting_account PDA signer seeds
          NOTE: token::burn requires the mint authority or the token account authority. The vesting_account PDA is the authority of vesting_token_account. Use the vesting_account PDA as signer for the burn CPI. But wait -- burn requires the authority of the TOKEN ACCOUNT, not the mint authority. Since vesting_token_account's authority is vesting_account PDA, this works.
       d. Set vesting_account.is_revoked = true
       e. Update bonding_curve.token_total_supply -= unvested (track deflation)
       f. Note: This does NOT affect virtual reserves or pricing -- burned vesting tokens were never in the curve. The total_supply tracking is for informational purposes.

    3. Wire into mod.rs and lib.rs.

    4. `anchor build` to verify full program compiles.

    5. Run `cargo test --manifest-path programs/baremint/Cargo.toml` to ensure math tests still pass.
  </action>
  <verify>
    `anchor build` succeeds with all 8 instructions (initialize, create_token, buy, sell, burn_for_access, claim_vested, withdraw_platform_fees, withdraw_creator_fees, revoke_vesting -- actually 9 total).
    IDL contains claim_vested and revoke_vesting instructions.
    All Rust unit tests pass.
  </verify>
  <done>
    claim_vested: enforces 30-day cliff, weekly claim windows, linear vesting over 60 days, transfers tokens to creator. revoke_vesting: admin-only, burns unvested tokens (deflationary), marks vesting as revoked. Full instruction set complete: initialize, create_token, buy, sell, burn_for_access, claim_vested, withdraw_platform_fees, withdraw_creator_fees, revoke_vesting.
  </done>
</task>

</tasks>

<verification>
- `anchor build` succeeds with all 9 instructions
- IDL at target/idl/baremint.json contains all instruction definitions
- Rust math unit tests pass
- BondingCurve struct includes fee accrual fields
- Burn mechanics are deflationary (tokens destroyed, SOL stays minus fees)
- Vesting enforces cliff + weekly windows
- Admin revocation burns unvested tokens
</verification>

<success_criteria>
- burn_for_access: SOL-denominated pricing, deflationary burn, fee extraction from reserves
- claim_vested: 30-day cliff, 60-day linear vest, weekly claim windows, revocation check
- withdraw_platform_fees + withdraw_creator_fees: authority-gated, lamport manipulation, rent-exempt safety
- revoke_vesting: admin-only, burns unvested, marks revoked
- Fee accrual pattern integrated into buy/sell/burn flows
</success_criteria>

<output>
After completion, create `.planning/phases/02-bonding-curve-smart-contract/02-03-SUMMARY.md`
</output>
