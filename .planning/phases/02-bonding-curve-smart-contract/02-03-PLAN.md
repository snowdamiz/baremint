---
phase: 02-bonding-curve-smart-contract
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - programs/baremint/src/instructions/burn_access.rs
  - programs/baremint/src/instructions/claim_vested.rs
  - programs/baremint/src/instructions/withdraw_fees.rs
  - programs/baremint/src/instructions/revoke_vesting.rs
  - programs/baremint/src/instructions/mod.rs
  - programs/baremint/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "Burning tokens for content access destroys the correct token amount based on SOL-denominated price -- no SOL returned to viewer, deflationary"
    - "Burn fees are extracted from the bonding_curve PDA reserves and tracked in fee accrual fields"
    - "Creator cannot claim vested tokens before 30-day cliff"
    - "Creator can claim vested tokens in weekly windows after cliff"
    - "Platform authority and creator can withdraw their accrued fees from bonding_curve PDA"
    - "Admin can revoke unvested tokens on creator ban (tokens burned, deflationary)"
  artifacts:
    - path: "programs/baremint/src/instructions/burn_access.rs"
      provides: "Burn-for-access instruction with SOL-denominated pricing, deflationary, no SOL returned"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/claim_vested.rs"
      provides: "Weekly vesting claim with 30-day cliff enforcement"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/withdraw_fees.rs"
      provides: "Fee withdrawal for platform and creator from bonding_curve PDA"
      contains: "pub fn handler"
    - path: "programs/baremint/src/instructions/revoke_vesting.rs"
      provides: "Admin revoke vesting on creator ban"
      contains: "pub fn handler"
  key_links:
    - from: "programs/baremint/src/instructions/burn_access.rs"
      to: "programs/baremint/src/math.rs"
      via: "calculate_tokens_for_sol_value for token amount calculation"
      pattern: "math::calculate_tokens_for_sol_value"
    - from: "programs/baremint/src/instructions/burn_access.rs"
      to: "programs/baremint/src/state/bonding_curve.rs"
      via: "Fee accrual into platform_fees_accrued and creator_fees_accrued"
      pattern: "platform_fees_accrued|creator_fees_accrued"
    - from: "programs/baremint/src/instructions/withdraw_fees.rs"
      to: "programs/baremint/src/state/bonding_curve.rs"
      via: "Reads accrued fee fields and transfers lamports from bonding_curve PDA"
      pattern: "platform_fees_accrued|creator_fees_accrued"
    - from: "programs/baremint/src/instructions/claim_vested.rs"
      to: "programs/baremint/src/state/vesting.rs"
      via: "VestingAccount state for cliff and claim tracking"
      pattern: "vesting_account\\.claimed_amount"
    - from: "programs/baremint/src/instructions/revoke_vesting.rs"
      to: "programs/baremint/src/state/global_config.rs"
      via: "GlobalConfig authority check for admin-only access"
      pattern: "global_config\\.authority"
---

<objective>
Implement the remaining four instructions: burn_for_access, claim_vested, withdraw_fees (platform + creator), and revoke_vesting.

Purpose: Completes the program's instruction set -- burn mechanics for content access (deflationary, no SOL returned to viewer), creator vesting with cliff/linear schedule, fee withdrawal from bonding_curve PDA for both platform and creators, and admin revocation for creator bans.
Output: All 9 program instructions compile and are ready for integration testing.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bonding-curve-smart-contract/02-CONTEXT.md
@.planning/phases/02-bonding-curve-smart-contract/02-RESEARCH.md
@.planning/phases/02-bonding-curve-smart-contract/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement burn_for_access and withdraw_fees instructions</name>
  <files>
    programs/baremint/src/instructions/burn_access.rs
    programs/baremint/src/instructions/withdraw_fees.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    NOTE: The fee accrual pattern (platform_fees_accrued, creator_fees_accrued on BondingCurve) and the SOL-in-bonding-curve-PDA architecture are ALREADY established by Plan 02-01 (struct definition) and Plan 02-02 (buy/sell implementation). This task only adds NEW instructions that use the existing pattern. Do NOT modify buy.rs, sell.rs, or bonding_curve.rs -- they are already correct.

    1. Create instructions/burn_access.rs:

       Context struct `BurnAccess`:
       - viewer: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint> (mut -- needed for burn which reduces supply)
       - viewer_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = viewer)
       - token_program: Program<Token>

       Handler `burn_for_access(ctx)`:
       a. Check burn_sol_price > 0, else error BurnDisabled
       b. Calculate tokens to burn: tokens_to_burn = calculate_tokens_for_sol_value(virtual_sol_reserves, virtual_token_reserves, burn_sol_price). This gives the number of tokens worth burn_sol_price SOL at current curve price.
       c. Check viewer has enough tokens: viewer_token_account.amount >= tokens_to_burn, error InsufficientTokens
       d. Calculate fees from the SOL equivalent: sol_equivalent = burn_sol_price (this IS the SOL value by definition). total_fee = calculate_fee(sol_equivalent, global_config.fee_bps). platform_fee = total_fee / 2. creator_fee = total_fee - platform_fee.
       e. Burn tokens from viewer's account: token::burn CPI (viewer signs, tokens_to_burn amount)
       f. DEFLATIONARY: No SOL is returned to the viewer. Tokens are destroyed. The fee SOL is extracted from the bonding_curve PDA's reserves and tracked in accrual fields.
       g. Update bonding_curve state:
          - real_token_reserves -= tokens_to_burn (fewer real tokens exist)
          - real_sol_reserves -= total_fee (fees extracted from reserves)
          - virtual_sol_reserves -= total_fee (fees reduce SOL in the curve pricing model)
          - virtual_token_reserves stays UNCHANGED (tokens burned, NOT returned to curve -- price goes UP for remaining holders)
          - token_total_supply -= tokens_to_burn (track total supply decrease)
          - platform_fees_accrued += platform_fee
          - creator_fees_accrued += creator_fee

    2. Create instructions/withdraw_fees.rs with TWO handlers:

       Context struct `WithdrawPlatformFees`:
       - authority: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"], constraint = authority.key() == global_config.authority @ Unauthorized)
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_mint: Account<Mint>

       Handler `withdraw_platform_fees(ctx)`:
       a. let amount = bonding_curve.platform_fees_accrued
       b. If amount == 0, return Ok(()) (nothing to withdraw)
       c. Transfer amount lamports from bonding_curve PDA to authority via lamport manipulation (program owns bonding_curve PDA)
       d. Ensure bonding_curve retains enough lamports for rent exemption: remaining >= Rent::get()?.minimum_balance(bonding_curve account data_len)
       e. Set bonding_curve.platform_fees_accrued = 0

       Context struct `WithdrawCreatorFees`:
       - creator: Signer (mut)
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()], constraint = creator.key() == bonding_curve.creator @ Unauthorized)
       - token_mint: Account<Mint>

       Handler `withdraw_creator_fees(ctx)`:
       a. let amount = bonding_curve.creator_fees_accrued
       b. If amount == 0, return Ok(())
       c. Transfer amount lamports from bonding_curve PDA to creator via lamport manipulation
       d. Ensure rent exemption retained
       e. Set bonding_curve.creator_fees_accrued = 0

    3. Wire burn_for_access, withdraw_platform_fees, and withdraw_creator_fees into mod.rs and lib.rs.

    4. `anchor build` to verify.
  </action>
  <verify>
    `anchor build` succeeds with all instructions.
    IDL contains burn_for_access, withdraw_platform_fees, withdraw_creator_fees instructions.
    `cargo test --manifest-path programs/baremint/Cargo.toml` still passes math tests.
    buy.rs and sell.rs are UNCHANGED from Plan 02-02 output.
  </verify>
  <done>
    burn_for_access: calculates tokens from SOL-denominated price, burns tokens (deflationary, no SOL returned to viewer), extracts fees from reserves into accrual fields, benefits remaining holders. withdraw_platform_fees: authority withdraws accrued platform fees from bonding_curve PDA. withdraw_creator_fees: creator withdraws accrued creator fees from bonding_curve PDA. All use the existing fee accrual pattern established in Plan 02-02.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement claim_vested and revoke_vesting instructions</name>
  <files>
    programs/baremint/src/instructions/claim_vested.rs
    programs/baremint/src/instructions/revoke_vesting.rs
    programs/baremint/src/instructions/mod.rs
    programs/baremint/src/lib.rs
  </files>
  <action>
    1. Create instructions/claim_vested.rs:

       Context struct `ClaimVested`:
       - creator: Signer (mut)
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"])
       - vesting_account: Account<VestingAccount> (mut, seeds = [b"vesting", token_mint.key().as_ref()], constraint = creator.key() == vesting_account.creator @ Unauthorized)
       - token_mint: Account<Mint>
       - vesting_token_account: Account<TokenAccount> (mut, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - creator_token_account: Account<TokenAccount> (mut, token::mint = token_mint, token::authority = creator)
       - token_program: Program<Token>

       Handler `claim_vested(ctx)`:
       a. Check is_revoked == false, error VestingRevoked
       b. Get current_time from Clock::get()?.unix_timestamp
       c. Calculate claimable amount using the vesting math:
          - cliff_end = start_timestamp + vesting_cliff_seconds
          - If current_time < cliff_end, error VestingCliffNotReached
          - elapsed_since_cliff = min(current_time - cliff_end, vesting_duration_seconds)
          - Snap to weekly windows: weeks_elapsed = elapsed_since_cliff / vesting_claim_interval_seconds
          - snapped_elapsed = weeks_elapsed * vesting_claim_interval_seconds
          - total_vested = total_allocation * snapped_elapsed / vesting_duration_seconds (u128 intermediate)
          - claimable = total_vested - claimed_amount
          - If claimable == 0, error VestingFullyClaimed (or just return Ok(()) -- prefer error so client knows nothing happened)
       d. Transfer claimable tokens from vesting_token_account to creator_token_account: token::transfer CPI with vesting_account PDA signer seeds
       e. Update vesting_account.claimed_amount += claimable

    2. Create instructions/revoke_vesting.rs:

       Context struct `RevokeVesting`:
       - authority: Signer (mut) -- must be global_config.authority
       - global_config: Account<GlobalConfig> (seeds = [b"global_config"], constraint = authority.key() == global_config.authority @ Unauthorized)
       - vesting_account: Account<VestingAccount> (mut, seeds = [b"vesting", token_mint.key().as_ref()])
       - token_mint: Account<Mint> (mut -- needed for burn)
       - vesting_token_account: Account<TokenAccount> (mut, seeds = [b"vesting_tokens", token_mint.key().as_ref()])
       - bonding_curve: Account<BondingCurve> (mut, seeds = [b"bonding_curve", token_mint.key().as_ref()])
       - token_program: Program<Token>

       Handler `revoke_vesting(ctx)`:
       a. Check vesting_account.is_revoked == false (idempotent -- if already revoked, just return Ok)
       b. Calculate unvested amount: unvested = total_allocation - claimed_amount
       c. Burn unvested tokens from vesting_token_account: token::burn CPI with vesting_account PDA signer seeds
          NOTE: token::burn requires the authority of the TOKEN ACCOUNT. Since vesting_token_account's authority is vesting_account PDA, this works.
       d. Set vesting_account.is_revoked = true
       e. Update bonding_curve.token_total_supply -= unvested (track deflation)
       f. Note: This does NOT affect virtual reserves or pricing -- burned vesting tokens were never in the curve. The total_supply tracking is for informational purposes.

    3. Wire into mod.rs and lib.rs.

    4. `anchor build` to verify full program compiles.

    5. Run `cargo test --manifest-path programs/baremint/Cargo.toml` to ensure math tests still pass.
  </action>
  <verify>
    `anchor build` succeeds with all 9 instructions (initialize, create_token, buy, sell, burn_for_access, claim_vested, withdraw_platform_fees, withdraw_creator_fees, revoke_vesting).
    IDL contains claim_vested and revoke_vesting instructions.
    All Rust unit tests pass.
  </verify>
  <done>
    claim_vested: enforces 30-day cliff, weekly claim windows, linear vesting over 60 days, transfers tokens to creator. revoke_vesting: admin-only, burns unvested tokens (deflationary), marks vesting as revoked. Full instruction set complete: initialize, create_token, buy, sell, burn_for_access, claim_vested, withdraw_platform_fees, withdraw_creator_fees, revoke_vesting.
  </done>
</task>

</tasks>

<verification>
- `anchor build` succeeds with all 9 instructions
- IDL at target/idl/baremint.json contains all instruction definitions
- Rust math unit tests pass
- Burn mechanics are deflationary: tokens destroyed, no SOL returned to viewer, fees extracted from reserves into accrual fields
- Vesting enforces cliff + weekly windows
- Admin revocation burns unvested tokens
- buy.rs and sell.rs are NOT modified by this plan -- they already use fee accrual pattern from Plan 02-02
</verification>

<success_criteria>
- burn_for_access: SOL-denominated pricing, deflationary burn (no SOL returned to viewer), fee extraction from reserves into accrual fields
- claim_vested: 30-day cliff, 60-day linear vest, weekly claim windows, revocation check
- withdraw_platform_fees + withdraw_creator_fees: authority-gated, lamport manipulation from bonding_curve PDA, rent-exempt safety
- revoke_vesting: admin-only, burns unvested, marks revoked
- No retroactive modifications to prior plan files
</success_criteria>

<output>
After completion, create `.planning/phases/02-bonding-curve-smart-contract/02-03-SUMMARY.md`
</output>
