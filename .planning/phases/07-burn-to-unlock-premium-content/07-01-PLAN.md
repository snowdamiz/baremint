---
phase: 07-burn-to-unlock-premium-content
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/solana/bonding-curve-math.ts
  - lib/solana/trade.ts
  - lib/content/access-control.ts
  - app/api/content/[postId]/media/route.ts
  - app/api/burn/[postId]/route.ts
  - .planning/ROADMAP.md
autonomous: true

must_haves:
  truths:
    - "Viewer can execute burn transaction and receive permanent unlock record"
    - "Permanent unlock record is stored after successful burn"
    - "burn_gated posts check unlock records before checking token balance"
    - "Gated media API returns unlocked content for users with unlock records"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "contentUnlock table with userId+postId unique index"
      contains: "content_unlock"
    - path: "lib/solana/bonding-curve-math.ts"
      provides: "calculateTokensForSolValue function"
      exports: ["calculateTokensForSolValue"]
    - path: "lib/solana/trade.ts"
      provides: "buildAndSendBurnForAccess transaction builder"
      exports: ["buildAndSendBurnForAccess"]
    - path: "app/api/burn/[postId]/route.ts"
      provides: "POST endpoint for burn-to-unlock execution and GET for burn quote"
      exports: ["POST", "GET"]
    - path: "lib/content/access-control.ts"
      provides: "Updated checkContentAccess with unlock record check"
  key_links:
    - from: "app/api/burn/[postId]/route.ts"
      to: "lib/solana/trade.ts"
      via: "buildAndSendBurnForAccess call"
      pattern: "buildAndSendBurnForAccess"
    - from: "app/api/burn/[postId]/route.ts"
      to: "lib/db/schema.ts"
      via: "contentUnlock insert after successful burn"
      pattern: "contentUnlock"
    - from: "lib/content/access-control.ts"
      to: "lib/db/schema.ts"
      via: "contentUnlock query for burn_gated access"
      pattern: "contentUnlock"
    - from: "app/api/content/[postId]/media/route.ts"
      to: "lib/content/access-control.ts"
      via: "checkContentAccess with userId for unlock check"
      pattern: "checkContentAccess"
---

<objective>
Build the complete backend for burn-to-unlock: database schema for permanent unlock records, TypeScript math for burn cost calculation, transaction builder mirroring buy/sell pattern, API routes for burn quote and execution, and access control updates to check unlock records.

Purpose: This is the backend foundation that enables the entire burn-to-unlock feature. Without it, viewers cannot burn tokens, and burn_gated content cannot be permanently unlocked.
Output: content_unlock table, calculateTokensForSolValue math, buildAndSendBurnForAccess transaction builder, burn API routes, updated access control.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/db/schema.ts
@lib/solana/trade.ts
@lib/solana/bonding-curve-math.ts
@lib/solana/bonding-curve-read.ts
@lib/content/access-control.ts
@app/api/content/[postId]/media/route.ts
@app/trade/[token]/actions.ts
@programs/baremint/src/instructions/burn_access.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema, math, and transaction builder for burn-for-access</name>
  <files>
    lib/db/schema.ts
    lib/solana/bonding-curve-math.ts
    lib/solana/trade.ts
  </files>
  <action>
**1. Add `contentUnlock` table to `lib/db/schema.ts`:**

```typescript
export const contentUnlock = pgTable("content_unlock", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull().references(() => user.id),
  postId: text("post_id").notNull().references(() => post.id),
  txSignature: text("tx_signature").notNull(),
  tokensBurned: text("tokens_burned").notNull(), // BigInt string
  createdAt: timestamp("created_at").notNull().defaultNow(),
}, (table) => [
  uniqueIndex("content_unlock_user_post_idx").on(table.userId, table.postId),
]);
```

Add the table after the existing `trade` table. Also add the `contentUnlock` table to the Drizzle relations if any exist in the schema.

Run `npx drizzle-kit push` to apply the migration.

**2. Add `calculateTokensForSolValue` to `lib/solana/bonding-curve-math.ts`:**

Port the Rust `calculate_tokens_for_sol_value` function. This uses CEILING division (burns more tokens, protocol-favorable):

```typescript
export function calculateTokensForSolValue(
  virtualSolReserves: bigint,
  virtualTokenReserves: bigint,
  solValue: bigint,
): bigint {
  if (solValue === BigInt(0)) return BigInt(0);
  // Ceiling division: (solValue * virtualTokenReserves + virtualSolReserves - 1) / virtualSolReserves
  const numerator = solValue * virtualTokenReserves + (virtualSolReserves - BigInt(1));
  return numerator / virtualSolReserves;
}
```

**3. Add `buildAndSendBurnForAccess` to `lib/solana/trade.ts`:**

Mirror the `buildAndSendBuy`/`buildAndSendSell` pattern. Key differences:
- Discriminator: `new Uint8Array([77, 60, 201, 5, 156, 231, 61, 29])` (burn_for_access)
- NO arguments in instruction data -- just the 8-byte discriminator
- Account layout: viewer(signer,mut), global_config(readonly), bonding_curve(mut), token_mint(mut -- tokens burned), viewer_token_account(mut), token_program(readonly)
- NOTE: token_mint is WRITABLE for burn (unlike buy/sell where it's readonly)
- No system_program needed (no SOL transfer)
- Import `calculateTokensForSolValue` from bonding-curve-math and `readBondingCurveAccount` from bonding-curve-read
- Before building the transaction, read bonding curve to get `burnSolPrice` and calculate `tokensRequired` using `calculateTokensForSolValue`
- Return `{ signature, tokensBurned: tokensRequired }` from the function

```typescript
export async function buildAndSendBurnForAccess(
  userId: string,
  mintAddress: string,
): Promise<{
  signature: string;
  tokensBurned: bigint;
}>
```

Use the existing `getUserSigner`, `deriveTradePDAs` (for globalConfig and bondingCurve PDAs), and the `pipe` transaction building pattern. The viewer's ATA is derived via `findAssociatedTokenPda` (same as buy/sell).
  </action>
  <verify>
Run `npx drizzle-kit push` -- should succeed.
Run `npx tsc --noEmit` -- no TypeScript errors in modified files.
Verify `calculateTokensForSolValue` is exported from bonding-curve-math.ts.
Verify `buildAndSendBurnForAccess` is exported from trade.ts.
  </verify>
  <done>
contentUnlock table exists in schema with unique index on userId+postId.
calculateTokensForSolValue matches Rust ceiling division behavior.
buildAndSendBurnForAccess builds a valid burn_for_access transaction using the same pattern as buy/sell.
  </done>
</task>

<task type="auto">
  <name>Task 2: Burn API routes and access control updates</name>
  <files>
    app/api/burn/[postId]/route.ts
    lib/content/access-control.ts
    app/api/content/[postId]/media/route.ts
  </files>
  <action>
**1. Create `app/api/burn/[postId]/route.ts` with GET (quote) and POST (execute) handlers:**

**GET handler (burn quote -- public, no auth needed for pricing info):**
- Look up the post to get `creatorTokenId`
- Look up `creatorToken` to get `mintAddress`
- Read bonding curve account to get `burnSolPrice` and reserves
- Calculate `tokensRequired` using `calculateTokensForSolValue(virtualSolReserves, virtualTokenReserves, burnSolPrice)`
- If `burnSolPrice === BigInt(0)`, return error "Burn is disabled for this token"
- Read `globalConfig` to calculate fee breakdown: `totalFee = calculateFee(burnSolPrice, feeBps)`, platform/creator fee split
- Return JSON: `{ tokensRequired, burnSolPrice, totalFee, platformFee, creatorFee, tokenTicker, mintAddress }` (all as strings). Including `mintAddress` in the response allows the frontend UnlockDialog to link to the trade page (`/trade/${mintAddress}`) without needing mintAddress as a separate prop.

**POST handler (execute burn -- authenticated):**
- Authenticate via `auth.api.getSession({ headers: await headers() })`
- Look up the post to get `creatorTokenId`, verify post exists and is `burn_gated`
- Check if user already has an unlock record in `contentUnlock` for this post -- if so, return error "Already unlocked"
- Look up `creatorToken` to get `mintAddress`
- Call `buildAndSendBurnForAccess(userId, mintAddress)` from trade.ts
- On success, insert `contentUnlock` record: `{ id: crypto.randomUUID(), userId, postId, txSignature: result.signature, tokensBurned: result.tokensBurned.toString() }`
- Return JSON: `{ success: true, signature, tokensBurned }`
- Wrap in try/catch, return appropriate errors (InsufficientTokens, BurnDisabled, etc.)

Use the same auth pattern as `app/trade/[token]/actions.ts` (auth.api.getSession). Use zod-free validation since postId comes from URL params.

**2. Update `lib/content/access-control.ts`:**

Add a new function `checkBurnUnlock` and update `checkContentAccess`:

```typescript
export async function checkBurnUnlock(
  userId: string,
  postId: string,
): Promise<boolean> {
  const [unlock] = await db
    .select()
    .from(contentUnlock)
    .where(
      and(
        eq(contentUnlock.userId, userId),
        eq(contentUnlock.postId, postId),
      ),
    )
    .limit(1);
  return !!unlock;
}
```

Update the `checkContentAccess` function signature to accept an optional 3rd parameter with defaults. The 3rd parameter MUST be optional with all fields optional so that existing callers continue to work without any changes:

```typescript
export async function checkContentAccess(
  postData: {
    accessLevel: string;
    tokenThreshold: string | null;
    creatorTokenId: string | null;
  },
  viewerWalletPublicKey: string | null,
  options: { viewerUserId?: string; postId?: string } = {},
): Promise<{ hasAccess: boolean; viewerBalance: string }>
```

For `burn_gated` posts when `options.viewerUserId` and `options.postId` are provided:
- First check if viewer has an unlock record via `checkBurnUnlock(viewerUserId, postId)` -- if yes, return `{ hasAccess: true, viewerBalance: "0" }`
- If no unlock record, fall through to the existing balance check (viewer might have enough tokens to see balance info in the unlock dialog)
- If options are not provided (backward-compatible path), skip the unlock check and just do the balance check as before

**IMPORTANT: Verify backward compatibility by grepping for all callers:**
```bash
grep -rn "checkContentAccess" --include="*.ts" --include="*.tsx" | grep -v "PLAN\|SUMMARY\|RESEARCH\|VERIFICATION\|node_modules\|\.planning"
```
Currently the only caller is `app/api/content/[postId]/media/route.ts`. The optional 3rd param with `= {}` default ensures this caller continues to work unchanged.

**3. Update `app/api/content/[postId]/media/route.ts`:**

Pass the additional `options` parameter to `checkContentAccess`:

```typescript
const accessResult = await checkContentAccess(
  {
    accessLevel: postData.accessLevel,
    tokenThreshold: postData.tokenThreshold,
    creatorTokenId: postData.creatorTokenId,
  },
  viewerWallet?.publicKey ?? null,
  { viewerUserId: session.user.id, postId },
);
```

This ensures that burn_gated posts check the permanent unlock record before falling back to token balance.

**4. Fix ROADMAP.md Phase 7 success criteria:**

Open `.planning/ROADMAP.md` and update the Phase 7 section:
- Success criterion #2: Change "Viewer sees burn cost and estimated SOL return before confirming a burn-to-unlock" to "Viewer sees burn cost in tokens and fee breakdown before confirming a burn-to-unlock"
- Success criterion #4: Change "SOL is returned from the bonding curve to the viewer's wallet proportional to tokens burned" to "Tokens are permanently destroyed (deflationary burn) and fees are extracted from curve reserves (platform + creator split)"
- Goal line: Change "with SOL returned from the curve" to "completing the token economy"
- Success criterion #1: Clarify "Creator can set a burn cost (in tokens) for premium/PPV posts" to "Creator's burn cost is determined by burn_sol_price set at token launch (shared across all burn_gated posts by that creator)"
  </action>
  <verify>
Run `npx tsc --noEmit` -- no TypeScript errors.
Verify GET /api/burn/[postId] route file exists and exports GET.
Verify POST /api/burn/[postId] route file exists and exports POST.
Verify checkContentAccess in access-control.ts accepts the new optional `options` parameter with `= {}` default.
Run `grep -rn "checkContentAccess" --include="*.ts" --include="*.tsx" | grep -v "\.planning"` and confirm ALL callers compile correctly with the new signature.
Verify the media API route passes userId and postId to checkContentAccess.
Verify ROADMAP.md Phase 7 no longer mentions "SOL return" or "SOL returned" in success criteria.
  </verify>
  <done>
GET /api/burn/[postId] returns burn quote with token cost and fee breakdown.
POST /api/burn/[postId] executes burn transaction and creates permanent unlock record.
checkContentAccess checks contentUnlock records for burn_gated posts before falling back to balance.
checkContentAccess signature is backward-compatible (existing callers work without changes).
Gated media API passes viewer identity for unlock record lookups.
ROADMAP.md Phase 7 success criteria corrected to reflect deflationary burn (no SOL return).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx drizzle-kit push` applies content_unlock table successfully
3. content_unlock table has unique index on (user_id, post_id)
4. calculateTokensForSolValue uses ceiling division matching Rust implementation
5. buildAndSendBurnForAccess follows same pattern as buildAndSendBuy/buildAndSendSell
6. GET /api/burn/[postId] returns burn cost info including tokens required and fee breakdown
7. POST /api/burn/[postId] requires auth, checks existing unlock, executes burn, creates unlock record
8. checkContentAccess returns hasAccess=true for burn_gated posts with existing unlock record
9. checkContentAccess signature is backward-compatible -- `grep -rn checkContentAccess` confirms all callers compile
10. Gated media API correctly passes userId for burn_gated unlock checks
11. ROADMAP.md Phase 7 success criteria no longer reference SOL return; burn cost clarified as per-token (set at launch)
</verification>

<success_criteria>
- The complete burn-to-unlock backend is functional: schema, math, transaction builder, API routes, access control
- A burn_gated post can be permanently unlocked by calling POST /api/burn/[postId]
- After unlocking, the gated media API returns full content (presigned URLs / signed tokens)
- Burn cost is derived from on-chain burn_sol_price, not from post tokenThreshold
</success_criteria>

<output>
After completion, create `.planning/phases/07-burn-to-unlock-premium-content/07-01-SUMMARY.md`
</output>
