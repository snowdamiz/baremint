---
phase: 07-burn-to-unlock-premium-content
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/db/schema.ts
  - lib/solana/bonding-curve-math.ts
  - lib/solana/trade.ts
  - lib/content/access-control.ts
  - app/api/content/[postId]/media/route.ts
  - app/api/burn/[postId]/route.ts
autonomous: true

must_haves:
  truths:
    - "Burn-for-access transaction can be built and sent to Solana"
    - "Permanent unlock record is stored after successful burn"
    - "burn_gated posts check unlock records before checking token balance"
    - "Gated media API returns unlocked content for users with unlock records"
  artifacts:
    - path: "lib/db/schema.ts"
      provides: "contentUnlock table with userId+postId unique index"
      contains: "content_unlock"
    - path: "lib/solana/bonding-curve-math.ts"
      provides: "calculateTokensForSolValue function"
      exports: ["calculateTokensForSolValue"]
    - path: "lib/solana/trade.ts"
      provides: "buildAndSendBurnForAccess transaction builder"
      exports: ["buildAndSendBurnForAccess"]
    - path: "app/api/burn/[postId]/route.ts"
      provides: "POST endpoint for burn-to-unlock execution and GET for burn quote"
      exports: ["POST", "GET"]
    - path: "lib/content/access-control.ts"
      provides: "Updated checkContentAccess with unlock record check"
  key_links:
    - from: "app/api/burn/[postId]/route.ts"
      to: "lib/solana/trade.ts"
      via: "buildAndSendBurnForAccess call"
      pattern: "buildAndSendBurnForAccess"
    - from: "app/api/burn/[postId]/route.ts"
      to: "lib/db/schema.ts"
      via: "contentUnlock insert after successful burn"
      pattern: "contentUnlock"
    - from: "lib/content/access-control.ts"
      to: "lib/db/schema.ts"
      via: "contentUnlock query for burn_gated access"
      pattern: "contentUnlock"
    - from: "app/api/content/[postId]/media/route.ts"
      to: "lib/content/access-control.ts"
      via: "checkContentAccess with userId for unlock check"
      pattern: "checkContentAccess"
---

<objective>
Build the complete backend for burn-to-unlock: database schema for permanent unlock records, TypeScript math for burn cost calculation, transaction builder mirroring buy/sell pattern, API routes for burn quote and execution, and access control updates to check unlock records.

Purpose: This is the backend foundation that enables the entire burn-to-unlock feature. Without it, viewers cannot burn tokens, and burn_gated content cannot be permanently unlocked.
Output: content_unlock table, calculateTokensForSolValue math, buildAndSendBurnForAccess transaction builder, burn API routes, updated access control.
</objective>

<execution_context>
@/Users/sn0w/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sn0w/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/db/schema.ts
@lib/solana/trade.ts
@lib/solana/bonding-curve-math.ts
@lib/solana/bonding-curve-read.ts
@lib/content/access-control.ts
@app/api/content/[postId]/media/route.ts
@app/trade/[token]/actions.ts
@programs/baremint/src/instructions/burn_access.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema, math, and transaction builder for burn-for-access</name>
  <files>
    lib/db/schema.ts
    lib/solana/bonding-curve-math.ts
    lib/solana/trade.ts
  </files>
  <action>
**1. Add `contentUnlock` table to `lib/db/schema.ts`:**

```typescript
export const contentUnlock = pgTable("content_unlock", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull().references(() => user.id),
  postId: text("post_id").notNull().references(() => post.id),
  txSignature: text("tx_signature").notNull(),
  tokensBurned: text("tokens_burned").notNull(), // BigInt string
  createdAt: timestamp("created_at").notNull().defaultNow(),
}, (table) => [
  uniqueIndex("content_unlock_user_post_idx").on(table.userId, table.postId),
]);
```

Add the table after the existing `trade` table. Also add the `contentUnlock` table to the Drizzle relations if any exist in the schema.

Run `npx drizzle-kit push` to apply the migration.

**2. Add `calculateTokensForSolValue` to `lib/solana/bonding-curve-math.ts`:**

Port the Rust `calculate_tokens_for_sol_value` function. This uses CEILING division (burns more tokens, protocol-favorable):

```typescript
export function calculateTokensForSolValue(
  virtualSolReserves: bigint,
  virtualTokenReserves: bigint,
  solValue: bigint,
): bigint {
  if (solValue === BigInt(0)) return BigInt(0);
  // Ceiling division: (solValue * virtualTokenReserves + virtualSolReserves - 1) / virtualSolReserves
  const numerator = solValue * virtualTokenReserves + (virtualSolReserves - BigInt(1));
  return numerator / virtualSolReserves;
}
```

**3. Add `buildAndSendBurnForAccess` to `lib/solana/trade.ts`:**

Mirror the `buildAndSendBuy`/`buildAndSendSell` pattern. Key differences:
- Discriminator: `new Uint8Array([77, 60, 201, 5, 156, 231, 61, 29])` (burn_for_access)
- NO arguments in instruction data -- just the 8-byte discriminator
- Account layout: viewer(signer,mut), global_config(readonly), bonding_curve(mut), token_mint(mut -- tokens burned), viewer_token_account(mut), token_program(readonly)
- NOTE: token_mint is WRITABLE for burn (unlike buy/sell where it's readonly)
- No system_program needed (no SOL transfer)
- Import `calculateTokensForSolValue` from bonding-curve-math and `readBondingCurveAccount` from bonding-curve-read
- Before building the transaction, read bonding curve to get `burnSolPrice` and calculate `tokensRequired` using `calculateTokensForSolValue`
- Return `{ signature, tokensBurned: tokensRequired }` from the function

```typescript
export async function buildAndSendBurnForAccess(
  userId: string,
  mintAddress: string,
): Promise<{
  signature: string;
  tokensBurned: bigint;
}>
```

Use the existing `getUserSigner`, `deriveTradePDAs` (for globalConfig and bondingCurve PDAs), and the `pipe` transaction building pattern. The viewer's ATA is derived via `findAssociatedTokenPda` (same as buy/sell).
  </action>
  <verify>
Run `npx drizzle-kit push` -- should succeed.
Run `npx tsc --noEmit` -- no TypeScript errors in modified files.
Verify `calculateTokensForSolValue` is exported from bonding-curve-math.ts.
Verify `buildAndSendBurnForAccess` is exported from trade.ts.
  </verify>
  <done>
contentUnlock table exists in schema with unique index on userId+postId.
calculateTokensForSolValue matches Rust ceiling division behavior.
buildAndSendBurnForAccess builds a valid burn_for_access transaction using the same pattern as buy/sell.
  </done>
</task>

<task type="auto">
  <name>Task 2: Burn API routes and access control updates</name>
  <files>
    app/api/burn/[postId]/route.ts
    lib/content/access-control.ts
    app/api/content/[postId]/media/route.ts
  </files>
  <action>
**1. Create `app/api/burn/[postId]/route.ts` with GET (quote) and POST (execute) handlers:**

**GET handler (burn quote -- public, no auth needed for pricing info):**
- Look up the post to get `creatorTokenId`
- Look up `creatorToken` to get `mintAddress`
- Read bonding curve account to get `burnSolPrice` and reserves
- Calculate `tokensRequired` using `calculateTokensForSolValue(virtualSolReserves, virtualTokenReserves, burnSolPrice)`
- If `burnSolPrice === BigInt(0)`, return error "Burn is disabled for this token"
- Read `globalConfig` to calculate fee breakdown: `totalFee = calculateFee(burnSolPrice, feeBps)`, platform/creator fee split
- Return JSON: `{ tokensRequired, burnSolPrice, totalFee, platformFee, creatorFee, tokenTicker }` (all as strings)

**POST handler (execute burn -- authenticated):**
- Authenticate via `auth.api.getSession({ headers: await headers() })`
- Look up the post to get `creatorTokenId`, verify post exists and is `burn_gated`
- Check if user already has an unlock record in `contentUnlock` for this post -- if so, return error "Already unlocked"
- Look up `creatorToken` to get `mintAddress`
- Call `buildAndSendBurnForAccess(userId, mintAddress)` from trade.ts
- On success, insert `contentUnlock` record: `{ id: crypto.randomUUID(), userId, postId, txSignature: result.signature, tokensBurned: result.tokensBurned.toString() }`
- Return JSON: `{ success: true, signature, tokensBurned }`
- Wrap in try/catch, return appropriate errors (InsufficientTokens, BurnDisabled, etc.)

Use the same auth pattern as `app/trade/[token]/actions.ts` (auth.api.getSession). Use zod-free validation since postId comes from URL params.

**2. Update `lib/content/access-control.ts`:**

Add a new function `checkBurnUnlock` and update `checkContentAccess`:

```typescript
export async function checkBurnUnlock(
  userId: string,
  postId: string,
): Promise<boolean> {
  const [unlock] = await db
    .select()
    .from(contentUnlock)
    .where(
      and(
        eq(contentUnlock.userId, userId),
        eq(contentUnlock.postId, postId),
      ),
    )
    .limit(1);
  return !!unlock;
}
```

Update the `checkContentAccess` function signature to accept an optional `viewerUserId` and `postId` parameter. For `burn_gated` posts:
- First check if viewer has an unlock record via `checkBurnUnlock(viewerUserId, postId)` -- if yes, return `{ hasAccess: true, viewerBalance: "0" }`
- If no unlock record, fall through to the existing balance check (viewer might have enough tokens to see balance info in the unlock dialog)

The function signature becomes:
```typescript
export async function checkContentAccess(
  postData: {
    accessLevel: string;
    tokenThreshold: string | null;
    creatorTokenId: string | null;
  },
  viewerWalletPublicKey: string | null,
  options?: { viewerUserId?: string; postId?: string },
): Promise<{ hasAccess: boolean; viewerBalance: string }>
```

**3. Update `app/api/content/[postId]/media/route.ts`:**

Pass the additional `options` parameter to `checkContentAccess`:

```typescript
const accessResult = await checkContentAccess(
  {
    accessLevel: postData.accessLevel,
    tokenThreshold: postData.tokenThreshold,
    creatorTokenId: postData.creatorTokenId,
  },
  viewerWallet?.publicKey ?? null,
  { viewerUserId: session.user.id, postId },
);
```

This ensures that burn_gated posts check the permanent unlock record before falling back to token balance.
  </action>
  <verify>
Run `npx tsc --noEmit` -- no TypeScript errors.
Verify GET /api/burn/[postId] route file exists and exports GET.
Verify POST /api/burn/[postId] route file exists and exports POST.
Verify checkContentAccess in access-control.ts accepts the new optional `options` parameter.
Verify the media API route passes userId and postId to checkContentAccess.
  </verify>
  <done>
GET /api/burn/[postId] returns burn quote with token cost and fee breakdown.
POST /api/burn/[postId] executes burn transaction and creates permanent unlock record.
checkContentAccess checks contentUnlock records for burn_gated posts before falling back to balance.
Gated media API passes viewer identity for unlock record lookups.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npx drizzle-kit push` applies content_unlock table successfully
3. content_unlock table has unique index on (user_id, post_id)
4. calculateTokensForSolValue uses ceiling division matching Rust implementation
5. buildAndSendBurnForAccess follows same pattern as buildAndSendBuy/buildAndSendSell
6. GET /api/burn/[postId] returns burn cost info including tokens required and fee breakdown
7. POST /api/burn/[postId] requires auth, checks existing unlock, executes burn, creates unlock record
8. checkContentAccess returns hasAccess=true for burn_gated posts with existing unlock record
9. Gated media API correctly passes userId for burn_gated unlock checks
</verification>

<success_criteria>
- The complete burn-to-unlock backend is functional: schema, math, transaction builder, API routes, access control
- A burn_gated post can be permanently unlocked by calling POST /api/burn/[postId]
- After unlocking, the gated media API returns full content (presigned URLs / signed tokens)
- Burn cost is derived from on-chain burn_sol_price, not from post tokenThreshold
</success_criteria>

<output>
After completion, create `.planning/phases/07-burn-to-unlock-premium-content/07-01-SUMMARY.md`
</output>
